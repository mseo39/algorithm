#톱니바퀴
"""
시간제한 2초
메모리제한 512MB

총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 
톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다.
이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다. 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다.

톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 
톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다. 
톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 

예를 들어, 아래와 같은 경우를 살펴보자.

두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다. 
여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다. 
2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고, 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 
따라서, 아래 그림과 같은 모양을 만들게 된다.

위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면, 2번 톱니바퀴가 반시계 방향으로 회전하게 되고, 
2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만, 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다.

톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다. 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다.

다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다. 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다. 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다. 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다.

출력
총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력한다. 점수란 다음과 같이 계산한다.

1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점
2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점
3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점
4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점

예제 입력
10101111
01111101
11001110
00000010
2
3 -1
1 1

예제 출력
7
"""
#설명
"""
문제 정리
* 톱니의 개수는 4개이면 왼쪽부터 1,2,3,4 번 이다
* 톱니바퀴는 8개의 톱으로 이루어져 있으며 N과 S극을 갖는다
  * N은 0 S은 1로 나타낸다
* 톱니바퀴를 회전하는데 방향은 반시계와 시계방향이 있다
  * 시계 방향은 1, 반시계 방향은 -1이다
* 회전을 하는 조건은 A가 시계방향으로 회전을 한다면
  * A 왼쪽에 있는 C의 2번 인덱스와 A의 6번 인덱스를 비교한다
  * A 오른쪽에 있는 B의 6번 인덱스와 A의 2번 인덱스를 비교한다
  * 만약 두 인덱스에 해당하는 값이 다르다면 A의 반대방향으로 회전한다
  * 만약 //값이 똑같다면 회전하지 않는다
  * 여기서 주의할 점은 해당 톱니바퀴가 회전되기 위해서는 바로 옆에 있는 톱니바퀴가 회전되어야 한다

나의 풀이
* 먼저 T 톱니바퀴를 회전한다면
  * 여기서 주의할 점은 톱니바퀴는 1부터 시작하지만 배열은 0부터 시작하기 때문에 0,1,2,3으로 하고 푼다
  * T-1(배열기준)를 기준으로 오른쪽으로 이동하면서 탐색한다
    * t=T~3이고 t-1과 t를 비교한다 
    * t-1의 2인덱스 t의 6인덱스 비교
      * 다르다면 현재 방향과 반대 방향으로 저장
      * 같다면 break
  * T-1을 기준으로 왼쪽으로 이동하면서 탐색한다
    * t=T-2~0이고 t+1과 t를 비교한다
    * t+1의 6인덱스 t의 2인덱스 비교
      * 다르다면 현재방향과 반대방향으로 저장
      * 같다면 break
* 회전에 따라 해당 인덱스에 있어야 하는 값 구하기
  * 시계방향으로 회전
    * 시계방향으로 1번 회전하면 2인덱스에는 1인덱스 값이 오게 된다
    * 3번 회전하면 2인덱스에는 7인덱스 값이 오게 된다
    * 즉 회전에 따른 인덱스=(구하고자하는 인덱스-회전개수+8)%8이다
  * 반시계 방향으로 회전
    * 반시계방향으로 1번 회전하면 6인덱스에는 7인덱스 값이 오게 된다
    * 회전에 따른 인덱스=(구하고자하는 인덱스+회전개수)%8
    * 근데 여기서 반시계방향은 음수로 표시되기 때문에 양수로 바꾸기 위해
    * 회전에 따른 인덱스=(구하고자하는 인덱스-회전개수)%8로 변경해준다
* 주의할 점
  * 회전하면서 주의할 점은 오른쪽이나 왼쪽으로 이동하면서 회전하고 그 회전에 따라 비교하면 안된다
  * 즉 현재 회전하기 전 값으로 비교해야하기 때문에 빈 배열을 만들어줘서 저장한 다음
  * 탐색이 다 끝나고 갱신해준다

헷갈려서 틀렸던 부분
* 시계방향으로 움직일 때 2인덱스는 3인덱스로 이동하지만 2인덱스에는 1인덱스가 온다는 사실을 깨닫지 못했다
* rotation_tmp=rotation[:]을 해줘서 현재 바뀐 방향에 대해서만 갱신해야 하는데 전것도 같이 갱신해버려 틀렸다
* 이동하면서 회전하면 방향을 계속 바꿔줘야 하는데 tmp = -r을 해줬다 즉 기준 톱니바퀴의 반대방향만 계속 저장한것
  * 그래서 tmp = -tmp를 해주면서 이동할때마다 방향이 바뀌게 했다
"""
import sys

# 원형으로 회전할 때 인덱스를 조정하는 함수
def chk(r, index):
    if r < 0:
        return (index - r) % 8
    else:
        return (index - r + 8) % 8

# 초기 행렬의 상태를 읽는다
state = [list(map(int, sys.stdin.readline().strip())) for _ in range(4)]
rotation = [0, 0, 0, 0]  # 각 행에 대한 초기 회전값
num = int(sys.stdin.readline())

# 각 회전 작업을 수행한다
for _ in range(num):
    rotation_tmp = [0, 0, 0, 0]  # 각 행에 대한 임시 회전값
    T, r = map(int, sys.stdin.readline().strip().split())
    tmp = r
    
    # T부터 3번째 행까지 오른쪽으로 회전을 확인한다
    for t in range(T, 4):
        if state[t][chk(rotation[t], 6)] != state[t - 1][chk(rotation[t - 1], 2)]:
            tmp = -tmp
            rotation_tmp[t] += tmp
        else:
            break
            
    tmp = r
    
    # T-2부터 0번째 행까지 왼쪽으로 회전을 확인한다
    for t in range(T - 2, -1, -1):
        if state[t][chk(rotation[t], 2)] != state[t + 1][chk(rotation[t + 1], 6)]:
            tmp = -tmp
            rotation_tmp[t] += tmp
        else:
            break
            
    rotation_tmp[T - 1] += r
    
    # 각 행에 대한 총 회전값을 업데이트한다
    for i in range(4):
        rotation[i] += rotation_tmp[i]

# 각 행의 최종 회전 위치에 따라 값을 합산하고 출력한다
print(sum([0 if state[0][chk(rotation[0], 0)] == 0 else 1,
           0 if state[1][chk(rotation[1], 0)] == 0 else 2,
           0 if state[2][chk(rotation[2], 0)] == 0 else 4,
           0 if state[3][chk(rotation[3], 0)] == 0 else 8]))
