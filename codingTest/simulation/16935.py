# 배열 돌리기 3
"""
시간제한 2초
메모리 제한 512MB

크기가 NxM인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다 연산은 총 6가지가 있다

1번 연산은 배열을 상하 반전시키는 연산이다.

1 6 2 9 8 4 → 4 2 9 3 1 8
7 2 6 9 8 2 → 9 2 3 6 1 5
1 8 3 4 2 9 → 7 4 6 2 3 1
7 4 6 2 3 1 → 1 8 3 4 2 9
9 2 3 6 1 5 → 7 2 6 9 8 2
4 2 9 3 1 8 → 1 6 2 9 8 4
   <배열>       <연산 결과>
2번 연산은 배열을 좌우 반전시키는 연산이다.

1 6 2 9 8 4 → 4 8 9 2 6 1
7 2 6 9 8 2 → 2 8 9 6 2 7
1 8 3 4 2 9 → 9 2 4 3 8 1
7 4 6 2 3 1 → 1 3 2 6 4 7
9 2 3 6 1 5 → 5 1 6 3 2 9
4 2 9 3 1 8 → 8 1 3 9 2 4
   <배열>       <연산 결과>
3번 연산은 오른쪽으로 90도 회전시키는 연산이다.

1 6 2 9 8 4 → 4 9 7 1 7 1
7 2 6 9 8 2 → 2 2 4 8 2 6
1 8 3 4 2 9 → 9 3 6 3 6 2
7 4 6 2 3 1 → 3 6 2 4 9 9
9 2 3 6 1 5 → 1 1 3 2 8 8
4 2 9 3 1 8 → 8 5 1 9 2 4
   <배열>       <연산 결과>
4번 연산은 왼쪽으로 90도 회전시키는 연산이다.

1 6 2 9 8 4 → 4 2 9 1 5 8
7 2 6 9 8 2 → 8 8 2 3 1 1
1 8 3 4 2 9 → 9 9 4 2 6 3
7 4 6 2 3 1 → 2 6 3 6 3 9
9 2 3 6 1 5 → 6 2 8 4 2 2
4 2 9 3 1 8 → 1 7 1 7 9 4
   <배열>       <연산 결과>
5, 6번 연산을 수행하려면 배열을 크기가 N/2×M/2인 4개의 부분 배열로 나눠야 한다. 아래 그림은 크기가 6×8인 배열을 4개의 그룹으로 나눈 것이고, 1부터 4까지의 수로 나타냈다.

1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
4 4 4 4 3 3 3 3
4 4 4 4 3 3 3 3
4 4 4 4 3 3 3 3
5번 연산은 1번 그룹의 부분 배열을 2번 그룹 위치로, 2번을 3번으로, 3번을 4번으로, 4번을 1번으로 이동시키는 연산이다.

3 2 6 3 1 2 9 7 → 2 1 3 8 3 2 6 3
9 7 8 2 1 4 5 3 → 1 3 2 8 9 7 8 2
5 9 2 1 9 6 1 8 → 4 5 1 9 5 9 2 1
2 1 3 8 6 3 9 2 → 6 3 9 2 1 2 9 7
1 3 2 8 7 9 2 1 → 7 9 2 1 1 4 5 3
4 5 1 9 8 2 1 3 → 8 2 1 3 9 6 1 8
     <배열>            <연산 결과>
6번 연산은 1번 그룹의 부분 배열을 4번 그룹 위치로, 4번을 3번으로, 3번을 2번으로, 2번을 1번으로 이동시키는 연산이다.

3 2 6 3 1 2 9 7 → 1 2 9 7 6 3 9 2
9 7 8 2 1 4 5 3 → 1 4 5 3 7 9 2 1
5 9 2 1 9 6 1 8 → 9 6 1 8 8 2 1 3
2 1 3 8 6 3 9 2 → 3 2 6 3 2 1 3 8
1 3 2 8 7 9 2 1 → 9 7 8 2 1 3 2 8
4 5 1 9 8 2 1 3 → 5 9 2 1 4 5 1 9
     <배열>            <연산 결과>

입력
첫째 줄에 배열의 크기 N, M과 수행해야 하는 연산의 수 R이 주어진다.

둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.

마지막 줄에는 수행해야 하는 연산이 주어진다. 연산은 공백으로 구분되어져 있고, 문제에서 설명한 연산 번호이며, 순서대로 적용시켜야 한다.

출력
입력으로 주어진 배열에 R개의 연산을 순서대로 수행한 결과를 출력한다.
"""
import sys

def firtt():
    """
    상하반전
    map_list[0~N//2][0~M] 즉 가운데 가로선을 중앙으로 위에 부분만 검사한다
    -> 왜냐하면 이동할 자리의 값과 스왑하면 되기 때문에 위에만 확인하면 됨
    상하반전은 y값은 그대로지만 x값만 변한다
    N=8,M=4일 때
    0,3에서 상하 반전을 하려면 7-0,3이 된다 즉 (N-1)-x를 하면 상하반전한 x의 값이 나온다

    ) 부분만 검사

    0,0 0,1 0,2 0,3 ) 
    1,0 1,1 1,2 1,3 )
    2,0 2,1 2,2 2,3 )
    3,0 3,1 3,2 3,3 )
    ---------------
    4,0 4,1 4,2 4,3
    5,0 5,1 5,2 5,3
    6,0 6,1 6,2 6,3
    7,0 7,1 7,2 7,3
    """
    for x in range(N//2):
        for y in range(M):
            map_list[x][y], map_list[(N-1)-x][y] = map_list[(N-1)-x][y], map_list[x][y]

def two():
    """
    좌우반전
    map_list[0~N][0~M//2] 즉 가운데 세로선을 중앙으로 왼쪽 부분만 검사한다
    -> 왜냐하면 이동할 자리의 값과 스왑하면 되기 때문에 왼쪽만 확인하면 됨
    좌우반전은 x값은 그대로지만 y값만 변한다
    N=8,M=4일 때
    2,1에서 좌우 반전을 하려면 2,3-1이 된다 즉 x,(M-1)-y를 하면 좌우반전한 위치가 나온다
    
    0,0 0,1 | 0,2 0,3
    1,0 1,1 | 1,2 1,3
    2,0 2,1 | 2,2 2,3
    3,0 3,1 | 3,2 3,3
    4,0 4,1 | 4,2 4,3
    5,0 5,1 | 5,2 5,3
    6,0 6,1 | 6,2 6,3
    7,0 7,1 | 7,2 7,3
    """
    for x in range(N):
        for y in range(M//2):
            map_list[x][y], map_list[x][(M-1)-y] = map_list[x][(M-1)-y], map_list[x][y]

def three():
    """
    0,0 0,1 0,2 0,3 
    1,0 1,1 1,2 1,3
    2,0 2,1 2,2 2,3
    3,0 3,1 3,2 3,3
    4,0 4,1 4,2 4,3
    5,0 5,1 5,2 5,3
    6,0 6,1 6,2 6,3
    7,0 7,1 7,2 7,3

    위를 오른쪽으로 90도 회전하면

    5,0 4,0 3,0 2,0 1,0 0,0
    5,1 4,1 3,1 2,1 1,1 0,1
    5,2 4,2 3,2 2,2 1,2 0,2
    5,3 4,3 3,3 2,3 1,3 0,3
    
    y= 0~3
    그러므로 y가 0일 때 5~0을 찾아 배열에 넣어주고
    y가 1일 때 5~0을 찾아 배열에 넣어주고 를 반복하면 된다
    """
    global map_list,M,N
    tmp=[]
    for x in range(M):
        tmp.append([map_list[y][x] for y in range(N-1,-1,-1)])
    map_list=tmp
    M,N=N,M

def four():
    """
    0,0 0,1 0,2 0,3 
    1,0 1,1 1,2 1,3
    2,0 2,1 2,2 2,3
    3,0 3,1 3,2 3,3
    4,0 4,1 4,2 4,3
    5,0 5,1 5,2 5,3
    6,0 6,1 6,2 6,3
    7,0 7,1 7,2 7,3

    위를 왼쪽으로 90도 회전하면

    0,3 1,3 2,3 3,3 4,3 5,3
    0,2 1,2 2,2 3,2 4,2 5,2
    0,1 1,1 2,1 3,1 4,1 5,1
    0,0 1,0 2,0 3,0 4,0 5,0
    
    y= 3~0
    그러므로 y가 3일 때 0~5을 찾아 배열에 넣어주고
    y가 1일 때 0~5을 찾아 배열에 넣어주고 를 반복하면 된다
    """
    global map_list,M,N
    tmp=[]
    for x in range(M-1,-1,-1):
        tmp.append([map_list[y][x] for y in range(N)])
    map_list=tmp
    M,N=N,M

def five():
    """
    1번 그룹의 부분 배열을 2번 그룹 위치로, 2번을 3번으로, 3번을 4번으로, 4번을 1번으로 이동
    
    0,0 0,1 | 0,2 0,3 
    1,0 1,1 | 1,2 1,3
    2,0 2,1 | 2,2 2,3
    3,0 3,1 | 3,2 3,3
    -----------------
    4,0 4,1 | 4,2 4,3
    5,0 5,1 | 5,2 5,3
    6,0 6,1 | 6,2 6,3
    7,0 7,1 | 7,2 7,3

    1->2로 이동하는 것을 보면 x값은 그대로인데 y값에 M//2(2)씩 이동하는 것을 볼 수 있다 1,1->1,3
    2->3로 이동하는 것을 보면 y값은 그대로인데 x값에 N//2(4)씩 이동하는 것을 볼 수 있다 2,3->6,3
    3->4로 이동하는 것을 보면 x값은 그대로인데 y값에 -M//2(2)씩 이동하는 것을 볼 수 있다 4,2->4,0
    3->4로 이동하는 것을 보면 y값은 그대로인데 x값에 -N//2(4)씩 이동하는 것을 볼 수 있다 6,1->2,1
    """
    global map_list
    tmp=[[0 for _ in range(M)] for _ in range(N)]
    #1
    for x in range(N//2):
        for y in range(M//2):
            tmp[x][y+M//2]=map_list[x][y]

    #2
    for x in range(N//2):
        for y in range(M//2,M):
            tmp[x+N//2][y]=map_list[x][y]

    #3
    for x in range(N//2,N):
        for y in range(M//2,M):
            tmp[x][y-M//2]=map_list[x][y]
    
    #4
    for x in range(N//2,N):
        for y in range(M//2):
            tmp[x-N//2][y]=map_list[x][y]

    map_list=tmp

def six():
    """
    5번 연산과 비슷한 방법
    """
    global map_list
    tmp=[[0 for _ in range(M)] for _ in range(N)]
    #1
    for x in range(N//2):
        for y in range(M//2):
            tmp[x+N//2][y]=map_list[x][y]

    #2
    for x in range(N//2):
        for y in range(M//2,M):
            tmp[x][y-M//2]=map_list[x][y]

    #3
    for x in range(N//2,N):
        for y in range(M//2,M):
            tmp[x-N//2][y]=map_list[x][y]
    
    #4
    for x in range(N//2,N):
        for y in range(M//2):
            tmp[x][y+M//2]=map_list[x][y]

    map_list=tmp



#세로 가로 연산 회수
N,M,R = map(int, sys.stdin.readline().strip().split())
map_list=[list(map(int, sys.stdin.readline().strip().split())) for _ in range(N)]
R_list = list(map(int, sys.stdin.readline().strip().split()))

for i in R_list:
    if i==1:
        firtt()
    elif i==2:
        two()
    elif i==3:
        three()
    elif i==4:
        four()
    elif i==5:
        five()
    else:
        six()

for i in map_list:
    print(*i)