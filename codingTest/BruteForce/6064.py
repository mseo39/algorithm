#카잉달력
"""
최근에 ICPC 탐사대는 남아메리카의 잉카 제국이 놀라운 문명을 지닌 카잉 제국을 토대로 하여 세워졌다는 사실을 발견했다
카잉 제국의 백성들은 특이한 달력을 사용한 것으로 알려져 있다.
그들은 M과 N보다 작거나 같은 두 개 자연수 x,y를 가지고 각 년도를 <x:y>와 같은 형식으로 표현하였다.
그들은 이 세상의 시초에 해당하는 첫번째 해를 <1:1>로 표현하고, 두번째 해를 <2:2>로 표현하였다
<x:y>의 다음 해를 표현한 것을 <x`:y`>이라고 하자.
만일 x<M이면 x` = x+1이고, 그렇지 않으면 x`=1이다
같은 방식으로 만일 y<N이면 y`=y+1이고, 그렇지 않으면 y`=1이다
<M:N>은 그들 달력의 마지막 해로서, 이해에 세강의 종말이 도래한다는 예언이 전해 온다

예를 들어, M=10이고 N=12라고 하자.
첫번째 해는 <1:1>로 표현되고, 11번째 해는 <1:11>로 표현된다. <3:1>은 13번째 해를 나타내고, <10:12>는 마지막인 60번째 해를 나타낸다

네개의 정수 M,N,x와 y가 주어질때, <M:N>이 카잉 달력의 마지막 해라고 하면 <x:y>는 몇번째 해를 나타내는지 구하는 프로그램을 작성하라

입력:
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 
입력의 첫번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다
각 테스트 데이터는 한 줄로 구성된다.
각 줄에는 네개의 정수 M, N, x, y가 주어진다
(1 ≤ M, N ≤ 40,000, 1 ≤ x ≤ M, 1 ≤ y ≤ N)
여기서 <M:N>은 카잉 달력의 마지막 해를 나타낸다.

출력
출력은 표준 출력을 사용한다. 각 테스트 데이터에 대해, 정수 k를 한 줄에 출력한다. 
여기서 k는 <x:y>가 k번째 해를 나타내는 것을 의미한다. 
만일 <x:y>에 의해 표현되는 해가 없다면, 즉, <x:y>가 유효하지 않은 표현이면, -1을 출력한다.

for _ in range(int(input())):
    M, N, x, y = map(int, input().split())

    tmp_x=0
    tmp_y=0
    k=0
    while(True):
        k+=1
        if tmp_x<M:
            tmp_x+=1
        else:
            tmp_x=1
        if tmp_y<N:
            tmp_y+=1
        else:
            tmp_y=1
        
        if x==tmp_x and y==tmp_y:
            print(k)
            break
        if tmp_x==M and tmp_y==N:
            print(-1)
            break
처음에 위처럼 풀었다가 시간초과가 날것 같았는데 역시나 시간초과가 발생했고
코드를 줄이다가 x==k%M and y==k%N 코드를 사용해서 풀면 간단하게 풀릴 것 같아서 나머지 정리를 찾아서 식을 정리하니
더 복잡해지더라,, 그래서 문제 푼 사람들의 풀이를 보니 x==k%M and y==k%N를 (k-x)%M==0 and (k-y)%N==0으로 바꿔서 문제를 풀면
빠르게 풀 수 있다는 것이었다,, 이런 방식으로 풀 수 있다는 건 처음 알았다 꼭 기억해놔야지

그 다음에는 k를 계속 1씩 더하면 시간초과가 난다는 것이다
이것도 (k-x)%M==0,(k-y)%N==0 둘 중 하나를 활용해서 문제를 풀어야 한다
나는 (k-x)%M==0를 가지고 문제를 풀 것이다 (k-x)가 M의 배수가 될려면 k가 x이거나(x-x) k가 x+dM이어야 한다(x+dM-x)
그래서 k를 x로 초기화하고 M씩 더해주는 것이다

그리고 문제에서 <10:12>는 마지막인 60번째 해를 나타낸다. 에서 마지막 해는 M과 N의 최소공배수라는 것을 알 수 있다
파이썬에서 제공하지 않는 라이브러리를 사용하지 않고 다음과 같은 코드를 사용할 수 있다

def gcd(a, b):  # 최대공약수
    while b > 0:
        a, b = b, a % b
    return a


def lcm(a, b):
    return a * b / gcd(a, b)
"""
import math

def find(M,N,x,y):
    lcm_num=math.lcm(M,N)
    k=x
    while(lcm_num>=k):
        if (k-x)%M==0 and (k-y)%N==0:
            return k
        k+=M
    return -1

for _ in range(int(input())):
    M, N, x, y = map(int, input().split())
    print(find(M,N,x,y))