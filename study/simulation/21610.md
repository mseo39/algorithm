# 마법사 상어와 비바라기

## 💡문제 분석 요약
```
시간제한 1초
메모리제한 1024MB

마법사 상어는 파이어볼, 토네이도, 파이어스톰, 물복사버그 마법을 할 수 있다. 
오늘 새로 배운 마법은 비바라기이다. 비바라기를 시전하면 하늘에 비구름을 만들 수 있다. 
오늘은 비바라기를 크기가 NxN인 격자에서 연습하려고 한다. 격자의 각 칸에는 바구니가 하나 있고, 바구니는 칸 전체를 차지한다. 
바구니에 저장할 수 있는 물의 양에는 제한이 없다. (r, c)는 격자의 r행 c열에 있는 바구니를 의미하고, 
A[r][c]는 (r, c)에 있는 바구니에 저장되어 있는 물의 양을 의미한다.

격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이다. 
마법사 상어는 연습을 위해 1번 행과 N번 행을 연결했고, 1번 열과 N번 열도 연결했다. 
즉, N번 행의 아래에는 1번 행이, 1번 행의 위에는 N번 행이 있고, 1번 열의 왼쪽에는 N번 열이, N번 열의 오른쪽에는 1번 열이 있다.

비바라기를 시전하면 (N, 1), (N, 2), (N-1, 1), (N-1, 2)에 비구름이 생긴다. 구름은 칸 전체를 차지한다. 

이제 구름에 이동을 M번 명령하려고 한다. i번째 이동 명령은 방향 di과 거리 si로 이루어져 있다. 
방향은 총 8개의 방향이 있으며, 8개의 정수로 표현한다. 
1부터 순서대로 ←, ↖, ↑, ↗, →, ↘, ↓, ↙ 이다. 이동을 명령하면 다음이 순서대로 진행된다.

* 모든 구름이 di 방향으로 si칸 이동한다.
* 각 구름에서 비가 내려 구름이 있는 칸의 바구니에 저장된 물의 양이 1 증가한다.
* 구름이 모두 사라진다.
* 2에서 물이 증가한 칸 (r, c)에 물복사버그 마법을 시전한다. 물복사버그 마법을 사용하면, 대각선 방향으로 거리가 1인 칸에 물이 있는 바구니의 수만큼 (r, c)에 있는 바구니의 물이 양이 증가한다.
  * 이때는 이동과 다르게 경계를 넘어가는 칸은 대각선 방향으로 거리가 1인 칸이 아니다.
  * 예를 들어, (N, 2)에서 인접한 대각선 칸은 (N-1, 1), (N-1, 3)이고, (N, N)에서 인접한 대각선 칸은 (N-1, N-1)뿐이다.
* 바구니에 저장된 물의 양이 2 이상인 모든 칸에 구름이 생기고, 물의 양이 2 줄어든다. 이때 구름이 생기는 칸은 3에서 구름이 사라진 칸이 아니어야 한다.

M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 구해보자.

입력
첫째 줄에 N, M이 주어진다.
둘째 줄부터 N개의 줄에는 N개의 정수가 주어진다. r번째 행의 c번째 정수는 A[r][c]를 의미한다.
다음 M개의 줄에는 이동의 정보 di, si가 순서대로 한 줄에 하나씩 주어진다.

출력
첫째 줄에 M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 출력한다.
```
## 💡문제 정리
* 맨 처음 구름은 (N, 1), (N, 2), (N-1, 1), (N-1, 2)에 있다
* 명령 1개당 하는 일
  * 이동하기
    * 모든 구름이 di 방향으로 si칸 이동
      * "1번 행과 N번 행을 연결했고, 1번 열과 N번 열도 연결" 했으므로 범위를 벗어나면 그 위치로 이동
    * 이동한 칸에 비가 내려 값이 +1 증가
  * 물 복사
    * "이동하기"에서 물이 증가한 바구니에서
    * 대각선 방향으로 거리가 1이고 물이 들어있는 바구니의 개수를 구한다
      * 여기서 "이동하기"처럼 범위를 벗어날 수 없음
    * 해당 바구니를 + 바구니 개수(대각선 1, 물>0)
  * 구름 만들기
    * 물의 양이 2 이상이고 "이동하기"의 결과인 칸이 아닌 곳을 찾는다
    * 해당 칸은 물을 -2를 해준다

## 💡알고리즘 설계
* visited 배열을 만들어서 구름의 위치를 저장해줬다
  * 맨 처음 구름은 (N-1, 0), (N-1, 1), (N-2, 0), (N-2, 1)에 있으므로 해당 칸을 1로 표시
  * 위치를 -1씩 해준 이유는 문제에는 번호가 1부터 시작하기 때문(배열은 0부터다)
* 명령 1개당 하는 일
  * 이동하기
    * 임시 배열 생성 (이동한 구름의 위치를 저장)
      * 원래 배열에 업데이트하면 그 우치에서 또 계산됨
    * 이중 for문으로 구름을 찾는다 (visited[x][y]가 1인 경우)
        * 모든 구름이 di 방향으로 si칸 이동
        * "1번 행과 N번 행을 연결했고, 1번 열과 N번 열도 연결" 했으므로 범위를 벗어나면 그 위치로 이동
            * 즉 %N을 해준다
        * 이동한 칸에 비가 내려 값이 +1 증가
        * 이동한 구름을 임시 배열에 업데이트
        * 전부 끝나면 원래 방문배열을 임시 배열로 업데이트
  * 물 복사
    * "이동하기"에서 물이 증가한 바구니에서
      * 이 부분은 visited에 저장되었으므로 visited=1인 부분을 찾는다
    * 대각선 방향으로 거리가 1이고 물이 들어있는 바구니의 개수를 구한다
      * loc에서 1,3,5,7이 대각선 방향이므로 range(1, 8, 2)함
      * 여기서 "이동하기"처럼 범위를 벗어날 수 없으므로 범위 검사
    * 해당 바구니를 + 바구니 개수(대각선 1, 물>0)
  * 구름 만들기
    * 물의 양이 2 이상이고 "이동하기"의 결과인 칸이 아닌 곳을 찾는다
      * "이동하기"의 결과인 칸인 곳은 visited=1로 되어있으므로 0인곳을 찾는다
    * 해당 칸은 물을 -2를 해준다

## 💡코드

```python
import sys

# 구름 이동 함수
def move(d, s):
    global visited
    # 임시 배열 초기화
    tmp = [[0 for _ in range(N)] for _ in range(N)]
    # 모든 구름에 대해 이동 처리
    for x in range(N):
        for y in range(N):
            if visited[x][y] == 1:
                # 이동한 위치 계산
                n_x = (x + loc[d - 1][0] * s) % N
                n_y = (y + loc[d - 1][1] * s) % N
                #비가 내리므로 1 증가
                A[n_x][n_y] += 1
                #이동한 위치를 저장
                tmp[n_x][n_y] = 1

    # 방문한 위치(구름 위치) 업데이트
    visited = tmp

# 물복사 함수
def copy():
    for x in range(N):
        for y in range(N):
            if visited[x][y] == 1:
                cnt = 0 #바구니 개수
                # 주변 대각선 방향으로 검사
                # loc에서 1,3,5,7이 대각선 방향이므로 range(1, 8, 2)함
                for i in range(1, 8, 2):
                    n_x = x + loc[i][0]
                    n_y = y + loc[i][1]
                    #이동하기와 다르게 범위를 벗어나면 안됨
                    if 0 <= n_x < N and 0 <= n_y < N and A[n_x][n_y] > 0:
                        #바구니 개수 증가
                        cnt += 1
                # 대각선 방향의 물이 든 바구니 개수만큼 증가
                A[x][y] += cnt

# 새로운 구름 생성 함수
def create():
    global visited
    # 임시 배열 초기화 (구름 위치)
    tmp = [[0 for _ in range(N)] for _ in range(N)]
    # 구름 찾기
    for x in range(N):
        for y in range(N):
            #물의 양이 2이상이고 "이동하기"에서 이동된 구름의 위치가 아니어야 함
            if A[x][y] >= 2 and visited[x][y] == 0:
                tmp[x][y] = 1 #해당 위치에 구름이 생성되었다는 것을 표시
                A[x][y] -= 2 #구름이 만들어 진 곳은 -2

    # 방문한 위치(구름 위치) 업데이트
    visited = tmp

# 입력 받기
N, M = map(int, sys.stdin.readline().strip().split())
A = [list(map(int, sys.stdin.readline().strip().split())) for _ in range(N)]
visited = [[0 for _ in range(N)] for _ in range(N)]
# 초기 구름 위치 설정
visited[N - 1][0] = 1
visited[N - 1][1] = 1
visited[N - 2][0] = 1
visited[N - 2][1] = 1

# 이동 방향 설정 (좌표 이동에 대한 정보)
loc = [[0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1]]

# M번의 이동과 변화 반복
for _ in range(M):
    d, s = map(int, sys.stdin.readline().strip().split())
    move(d, s)
    copy()
    create()

# 남아있는 물의 양 합산
print(sum([sum(i) for i in A]))
```

## 💡시간복잡도
O(N^2)

## 💡 틀린 이유

## 💡 다른 풀이


## 💡 느낀점 or 기억할정보
느낀 점은 딱히 없지만,,
이동한 후에 원래 방문 배열에 이동한 것을 업데이트 해버리면 for문을 돌리다가 업데이트 한것을 만나서 잘못 계산 될 수 있으니
임시 배열을 만들어서 저장한 뒤에 업데이트 하자