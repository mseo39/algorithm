#마법사 상어와 파이어볼

## 💡문제 분석 요약
```
"""
시간제한 1초
메모리 제한 512MB

마법사 상어는 파이어볼, 토네이도, 파이어스톰, 물복사버그 마법을 할 수 있다. 오늘 새로 배운 마법은 비바라기이다. 
비바라기를 시전하면 하늘에 비구름을 만들 수 있다. 오늘은 비바라기를 크기가 NxN인 격자에서 연습하려고 한다. 
* 격자의 각 칸에는 바구니가 하나 있고, 바구니는 칸 전체를 차지한다. 
* 바구니에 저장할 수 있는 물의 양에는 제한이 없다. 
* (r, c)는 격자의 r행 c열에 있는 바구니를 의미하고, 
* A[r][c]는 (r, c)에 있는 바구니에 저장되어 있는 물의 양을 의미한다.

격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (N, N)이다. 마법사 상어는 연습을 위해 1번 행과 N번 행을 연결했고, 
1번 열과 N번 열도 연결했다. 즉, N번 행의 아래에는 1번 행이, 1번 행의 위에는 N번 행이 있고, 1번 열의 왼쪽에는 N번 열이, N번 열의 오른쪽에는 1번 열이 있다.

비바라기를 시전하면 (N, 1), (N, 2), (N-1, 1), (N-1, 2)에 비구름이 생긴다. 구름은 칸 전체를 차지한다. 

이제 구름에 이동을 M번 명령하려고 한다. 
i번째 이동 명령은 방향 di과 거리 si로 이루어져 있다. 
방향은 총 8개의 방향이 있으며, 8개의 정수로 표현한다. 
1부터 순서대로 ←, ↖, ↑, ↗, →, ↘, ↓, ↙ 이다. 이동을 명령하면 다음이 순서대로 진행된다.

* 모든 구름이 di 방향으로 si칸 이동한다.
* 각 구름에서 비가 내려 구름이 있는 칸의 바구니에 저장된 물의 양이 1 증가한다.
* 구름이 모두 사라진다.
* 2에서 물이 증가한 칸 (r, c)에 물복사버그 마법을 시전한다. 물복사버그 마법을 사용하면, 대각선 방향으로 거리가 1인 칸에 물이 있는 바구니의 수만큼 (r, c)에 있는 바구니의 물이 양이 증가한다.
  * 이때는 이동과 다르게 경계를 넘어가는 칸은 대각선 방향으로 거리가 1인 칸이 아니다.
  * 예를 들어, (N, 2)에서 인접한 대각선 칸은 (N-1, 1), (N-1, 3)이고, (N, N)에서 인접한 대각선 칸은 (N-1, N-1)뿐이다.
* 바구니에 저장된 물의 양이 2 이상인 모든 칸에 구름이 생기고, 물의 양이 2 줄어든다. 이때 구름이 생기는 칸은 3에서 구름이 사라진 칸이 아니어야 한다.

M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 구해보자.

입력
첫째 줄에 N, M이 주어진다.
둘째 줄부터 N개의 줄에는 N개의 정수가 주어진다. r번째 행의 c번째 정수는 A[r][c]를 의미한다.

다음 M개의 줄에는 이동의 정보 di, si가 순서대로 한 줄에 하나씩 주어진다.

출력
첫째 줄에 M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 출력한다.
```
## 💡문제 정리
* 명령 1개당 하는 일
  * 이동하기
    * 파이어볼이 있으면 해당 파이어볼에 해당하는 속력과 방향을 토대로 이동한다
  * 합치기
    * 한 칸에 파이어볼이 2개 이상 있는 것을 찾는다
    * 해당 칸의의 파이어볼을 합친 후 4개로 나눈다
      * 질량은 ⌊(합쳐진 파이어볼 질량의 합)/5⌋이다.
        * 질량이 0인 파이어볼은 소멸되어 없어진다.
      * 속력은 ⌊(합쳐진 파이어볼 속력의 합)/(합쳐진 파이어볼의 개수)⌋
      * 합쳐지는 파이어볼의 방향이 모두 홀수이거나 모두 짝수이면, 방향은 0, 2, 4, 6이 되고, 그렇지 않으면 1, 3, 5, 7이 된다.

## 💡알고리즘 설계
3차원 배열을 만들었다 왜? 해당칸에 2개 이상의 파이어볼이 있을 수 있기 때문

* 명령 1개당 하는 일
  * 이동하기
    * 임시배열을 만든다
    * 이중 for문을 통해 파이어볼이 있는 것을 찾는다 0 이상
    * 이동 위치 계산
      * 문제에서 "1번부터 N번까지 번호가 매겨져 있고, 1번 행은 N번과 연결되어 있고, 1번 열은 N번 열과 연결"이라고 했다
        * 즉 이어져있다는 것
        * n_x = (x + loc[i["d"]][0] * i["s"]) % N 이렇게 계산한 후 % N을 해준다
    * 이동 후 임시 배열에 추가
    * 원래 배열을 임시 배열로 업데이트
  * 합치기
    * 이중 for문을 통해 파이어볼이 2개 이상있는 칸을 찾는다
    * 해당 칸의의 파이어볼을 합친 후 4개로 나눈다
      * 해당 칸에 있는 파이어볼 질량을 합친다
      * 해당 칸에 있는 파이어볼 속력을 합친다
      * 방향이 짝수인 개수와 홀수인 개수를 구한다
      * A[x][y] = [] 해당 칸을 비어준다
        * 새로운 값이 추가될 것이기 때문

      * 질량은 ⌊(합쳐진 파이어볼 질량의 합)/5⌋
        * 여기서 질량이 0이 된다면 소멸되므로 continue 해준다 A[x][y] = []해줬으니 소멸된것으로 됨
      * 속력은 ⌊(합쳐진 파이어볼 속력의 합)/(합쳐진 파이어볼의 개수)⌋
      * 홀수의 개수 또는 짝수의 개수가 파이어볼 개수와 같다면 방향은 0, 2, 4, 6이 되고
        * 그렇지 않으면 1, 3, 5, 7이 된다.

## 💡코드

```python
import sys

# 이동 방향 설정
loc = [[-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1]]

def move():
    global A
    # 임시 배열 초기화
    tmp = [[[] for _ in range(N)] for _ in range(N)]
    # 모든 파이어볼 이동 처리
    for x in range(N):
        for y in range(N):
            if len(A[x][y]) != 0:
                for i in A[x][y]:
                    # 이동 위치 계산
                    n_x = (x + loc[i["d"]][0] * i["s"]) % N
                    n_y = (y + loc[i["d"]][1] * i["s"]) % N
                    # 이동한 위치에 파이어볼 정보 추가
                    tmp[n_x][n_y].append({"m": i["m"], "s": i["s"], "d": i["d"]})
    # 현재 배열 업데이트
    A = tmp

def divide():
    # 모든 칸에 대해 파이어볼 분리 처리
    for x in range(N):
        for y in range(N):
            if len(A[x][y]) > 1:
                # 파이어볼 정보 합산 초기화
                m_sum = 0
                s_sum = 0
                odd = 0
                even = 0
                # 파이어볼 정보 합산
                for i in A[x][y]:
                    m_sum += i["m"]
                    s_sum += i["s"]
                    # 방향 홀짝 여부 확인
                    if i["d"] % 2 == 0:
                        even += 1
                    else:
                        odd += 1
                cnt = len(A[x][y])
                A[x][y] = []
                # 파이어볼 분리 및 추가
                m = m_sum // 5
                if m == 0:
                    continue
                s = s_sum // cnt
                if even == cnt or odd == cnt:
                    d = [0, 2, 4, 6]  # 방향이 모두 홀수거나 짝수인 경우
                else:
                    d = [1, 3, 5, 7]  # 방향이 홀수와 짝수가 섞인 경우
                for i in d:
                    A[x][y].append({"m": m, "s": s, "d": i})

# 입력 받기
N, M, K = map(int, sys.stdin.readline().strip().split())
A = [[[] for _ in range(N)] for _ in range(N)]
for _ in range(M):
    r, c, m, s, d = map(int, sys.stdin.readline().strip().split())
    A[r - 1][c - 1].append({"m": m, "s": s, "d": d})

# K번 이동 및 분리 수행
for _ in range(K):
    move()
    divide()

# 남아있는 파이어볼 질량 합산
cnt = 0
for x in range(N):
    for y in range(N):
        for i in A[x][y]:
            cnt += i["m"]
print(cnt)
```

## 💡시간복잡도
O(N^2)

## 💡 틀린 이유

## 💡 다른 풀이


## 💡 느낀점 or 기억할정보
1번부터 N번까지 번호가 매겨져 있고, 1번 행은 N번과 연결되어 있고, 1번 열은 N번 열과 연결

이 부분이 이해가 잘 안갔다 그런데 찾아보니 범위를 벗어나도 해당하는 곳으로 갈 수 있다는 뜻이었다