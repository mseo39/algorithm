# 마법사 상어와 토네이도

## 💡문제 분석 요약
```
시간제한 1초
메모리 제한 512MB

마법사 상어가 토네이도를 배웠고, 오늘은 토네이도를 크기가 NxN인 격자로 나누어진 모래밭에서 연습하려고 한다. 
위치 (r, c)는 격자의 r행 c열을 의미하고, A[r][c]는 (r, c)에 있는 모래의 양을 의미한다.
토네이도를 시전하면 격자의 가운데 칸부터 토네이도의 이동이 시작된다. 토네이도는 한 번에 한 칸 이동한다. 다음은 N = 7인 경우 토네이도의 이동이다.

토네이도가 한 칸 이동할 때마다 모래는 다음과 같이 일정한 비율로 흩날리게 된다.
토네이도가 x에서 y로 이동하면, y의 모든 모래가 비율과 α가 적혀있는 칸으로 이동한다. 
비율이 적혀있는 칸으로 이동하는 모래의 양은 y에 있는 모래의 해당 비율만큼이고, 계산에서 소수점 아래는 버린다. 
α로 이동하는 모래의 양은 비율이 적혀있는 칸으로 이동하지 않은 남은 모래의 양과 같다. 
모래가 이미 있는 칸으로 모래가 이동하면, 모래의 양은 더해진다. 
위의 그림은 토네이도가 왼쪽으로 이동할 때이고, 다른 방향으로 이동하는 경우는 위의 그림을 해당 방향으로 회전하면 된다.

토네이도는 (1, 1)까지 이동한 뒤 소멸한다. 모래가 격자의 밖으로 이동할 수도 있다. 토네이도가 소멸되었을 때, 격자의 밖으로 나간 모래의 양을 구해보자.

입력
첫째 줄에 격자의 크기 N이 주어진다. 둘째 줄부터 N개의 줄에는 격자의 각 칸에 있는 모래가 주어진다. 
r번째 줄에서 c번째 주어지는 정수는 A[r][c] 이다.

출력
격자의 밖으로 나간 모래의 양을 출력한다.
```
![alt text](20057.png)
## 💡문제 정리
* 왼쪽 사진처럼 토네이도를 그리면서 움직이고
* 이동하면서 오른쪽 그림처럼 비율에 맞게 모래가 날라간다
  *  모래의 양은 y에 있는 모래의 해당 비율만큼이고 소수점은 버린다
  * α로 이동하는 모래의 양은 비율이 적혀있는 칸으로 이동하지 않은 남은 모래의 양
  * 모래가 이미 있는 칸으로 모래가 이동하면, 모래의 양은 더해진다
  * 토네이도가 왼쪽으로 이동할 때이고, 다른 방향으로 이동하는 경우는 위의 그림을 해당 방향으로 회전
* 모래가 격자의 밖으로 이동할 수도 있다. 
  * 토네이도가 소멸되었을 때, 격자의 밖으로 나간 모래의 양을 구해보자.

## 💡알고리즘 설계
* 주석 참고
* 토네이도 이동
  * 일단 왼쪽 그림을 보면 다음과 같은 규칙을 찾을 수 있다
    * 똑같은 길이를 2번 사용한다
    * 길이만큼 이동하면 방향을 바꾼다
  * 따라서 n_size(해당길이), cnt(해당 길이로 얼마나 전진했는지)를 이용해서 두개의 값이 같다면
    (즉, 해당길이만큼 이동했다면)
    * 방향을 바꿔준다
    * 여기서 flag가 있는데 flag는 해당길이를 몇번 사용했냐이다
      * 0 1 0 1 되는건데 0이라면 1로 1이라면 2번한것이므로 다시 0으로 변경한다
      * 그리고 그림을 보면 한 길이를 2번 쓰고 늘린다 따라서 flag를 0으로 바꾸면서 길이도 늘린다
* 모래 날리기
  * 모래 비율은 어디로 이동하냐에 따라 달라진다고 한다
  * 그래서 각 비율을 인덱스화 해준다 0인덱스 2% 1인덱스에 10% 이렇게
  * 그리고 그 인덱스에 맞게 위치를 저장해준다(각 회전별로)
    * 즉 2차원 배열을 만드는데 내가 어디 방향으로 이동했는지는 D에 저장되어있고 왼,아,오,위 로 되어있기 때문에 이 방향에 맞게 이차원 배열은 만든다
  * 결과로 격자 밖에 나간 모래의 합을 구해야 하므로 범위를 벗어나면 result에 + 해준다

## 💡코드

```python
import sys

def move():
    global D  # 현재 이동 방향을 나타내는 변수
    cnt = 0  # 현재 방향으로 이동한 횟수를 세는 변수
    n_size = 1  # 현재 나선형 루프의 크기를 나타내는 변수
    flag = 0  # n_size를 증가시킬지 여부를 토글하는 플래그

    while not (c[0] == 0 and c[1] == 0):  # 중앙에 도달할 때까지 반복
        c[0] += loc[D][0]  # 현재 방향을 기반으로 행 위치 업데이트
        c[1] += loc[D][1]  # 현재 방향을 기반으로 열 위치 업데이트
        if A[c[0]][c[1]] > 0:  # 현재 셀에 마법이 있는 경우
            masic()  # 마법을 분배하는 함수 호출

        cnt += 1  # 이동 횟수 카운트 증가
        if cnt == n_size:  # 이동한 횟수가 현재 나선형 루프 크기와 같을 때
            cnt = 0  # 이동 횟수 초기화
            
            D = (D + 1) % 4  # 시계방향으로 방향 변경
            if flag == 0:  # 나선형 루프 크기를 증가시킬 때
                flag = 1
            else:
                flag = 0  # 플래그 재설정
                n_size += 1  # 나선형 루프 크기 증가

            
def masic():
    global result  # 결과를 누적할 변수
    v_tmp = A[c[0]][c[1]]  # 현재 셀의 모래 값을 저장하는 임시 변수

    for i in range(9):  # 모래 분배 패턴을 반복
        tmp = A[c[0]][c[1]] * V[i] // 100  # 분배될 모래의 비율 계산
        v_tmp -= tmp  # α 모래 계산 (α에는 현재모래-날라간 모래)를 가짐
        if not (0 <= c[0] + V_list[D][i][0] < N and 0 <= c[1] + V_list[D][i][1] < N):  # 모래가 그리드 바깥으로 분배되는 경우 ..__결과로 격자 밖으로 나간 모래 양을 계산하기 위함
            result += tmp  # 결과 증가
        else:
            A[c[0] + V_list[D][i][0]][c[1] + V_list[D][i][1]] += tmp  # 인접한 셀에 마법 분배
    
    if not (0 <= c[0] + V_list[D][9][0] < N and 0 <= c[1] + V_list[D][9][1] < N):  # 나머지 모래가 그리드 바깥으로 분배되는 경우__..결과로 격자 밖으로 나간 모래 양을 계산하기 위함
        result += v_tmp  # 결과 증가
    else:
        A[c[0] + V_list[D][9][0]][c[1] + V_list[D][9][1]] += v_tmp  # 나머지 모래 α에 저장


N = int(sys.stdin.readline())  # 그리드 크기 입력
A = [list(map(int, sys.stdin.readline().strip().split())) for _ in range(N)]  # 그리드에 모래 값 입력

result = 0  # 모래가 그리드 바깥으로 나가는 것을 누적할 변수 초기화
c = [N // 2, N // 2]  # 현재 위치를 그리드의 중앙으로 초기화
loc = [[0, -1], [1, 0], [0, 1], [-1, 0]]  # 왼쪽, 아래, 오른쪽, 위로 이동하는 방향 벡터 정의
D = 0  # 초기 방향은 왼쪽으로 설정
V = [2, 10, 7, 1, 5, 10, 7, 1, 2]  # 모래 분배 비율 정의
V_list = [  # 각 방향에 대한 모래 분배 패턴 정의
    [[-2, 0], [-1, -1], [-1, 0], [-1, 1], [0, -2], [1, -1], [1, 0], [1, 1], [2, 0], [0, -1]],
    [[0, -2], [1, -1], [0, -1], [-1, -1], [2, 0], [1, 1], [0, 1], [-1, 1], [0, 2], [1, 0]],
    [[2, 0], [1, 1], [1, 0], [1, -1], [0, 2], [-1, 1], [-1, 0], [-1, -1], [-2, 0], [0, 1]],
    [[0, 2], [-1, 1], [0, 1], [1, 1], [-2, 0], [-1, -1], [0, -1], [1, -1], [0, -2], [-1, 0]]
]

move()  # 이동 및 마법 분배 실행

print(result)  # 그리드 바깥으로 나간 마법을 출력

```

## 💡시간복잡도
O(N^2)

## 💡 틀린 이유

## 💡 다른 풀이


## 💡 느낀점 or 기억할정보
느낀점은,, 저 비율을 회전시킬 수 있지 않을까?에서 시간을 뻬앗겼는데,,저렇게 직접할 수 있는거면 노가다로 빨리 끝내는게 이득인 것 같다
문제를 풀때 코드를 적게 쓸려고 하지말고 효율에 영향을 끼치지 않을 것 같다면 그냥 하자 노가다.

위 토네이도 이동 방식은 다른 문제에서 쓰인다고 하니 기억해두자