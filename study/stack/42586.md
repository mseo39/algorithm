# 기능개발

## 💡문제

```
프로그래머스 팀에서는 기능 개선 작업을 수행중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.
또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 
이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 
각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

제한 사항
* 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
* 작업 진도는 100 미만의 자연수입니다.
* 작업 속도는 100 이하의 자연수입니다.

배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 
예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.

progresses	               speeds	            return
[93, 30, 55]	             [1, 30, 5]	        [2, 1]
[95, 90, 99, 99, 80, 99]   [1, 1, 1, 1, 1, 1]	[1, 3, 2]
```

## 💡알고리즘 설계
* 앞에 있는 기능이 100이라면 100인 기능들을 앞에서부터 순서대로 꺼내준다
  * 100이 아닌 기능을 만날 때까지
* 각 기능에 개발 속도만큼 추가

## 💡코드

```python
def solution(progresses, speeds):
    answer = []  # 각 작업이 완료되는데 걸리는 일 수를 저장할 리스트

    i = 0  # progresses 리스트의 인덱스를 가리키는 변수 초기화
    end = len(progresses)  # 작업의 총 개수를 저장

    # 모든 작업을 확인할 때까지 반복
    while i < end:
        cnt = 0  # 현재 작업 진행률이 100% 이상인 작업의 수를 세는 변수 초기화

        # 현재 작업 진행률이 100% 이상인지 확인
        if progresses[i] >= 100:
            # 현재 작업부터 연속적으로 진행률이 100% 이상인 작업들을 세어나감
            while i < end and progresses[i] >= 100:
                i += 1  # 다음 작업으로 인덱스 이동
                cnt += 1  # 완료된 작업 수 증가
            answer.append(cnt)  # 연속된 완료된 작업 수를 리스트에 추가

        # 아직 완료되지 않은 작업의 진행률을 갱신
        for index in range(i, end):
            progresses[index] += speeds[index]

    return answer  # 각 작업이 완료되는데 걸리는 일 수를 반환

```

## 💡시간복잡도

## 💡 틀린 이유

## 💡 다른 풀이
나는 하루하루마다 계산해서 구해줬다면 다른 풀이는 각 기능들이 100이 될려면 며칠이 필요한지 구하는 거였다
따라서 다음과 같이 진행된다
* [93, 30, 55], [1, 30, 5]
* 93을 100으로 만들려면 7일이 필요 Q=[[7,1]]
* 30을 100으로 만들려면 3일이 필요
  * 근데 여기서 (100-30)//30은 2가 되는데 100을 넘기 위해서는 3이 되어야 한다
  * 이유는 // 는 내림하기 때문으로 -((30 - 100) // 30)을 해준다
  * 음수에서 내림은 절대값이 커지기 때문 즉, -2.3에서 내림하면 -3이 된다
* 여기서 3일을 7일보다 작기 때문에 7일이 끝나면 3일 기능도 같이 배포 되므로
  * Q=[[7,2]]
* 55을 100으로 만들려면 9일이 필요
* 여기서 9일은 7일 보다 크므로 같이 나갈 수 없다 따라거 Q에 추가 
  * Q=[[7,2], [9,1]]

```python
def solution(progresses, speeds):
    Q = []  # 스택 구조를 사용할 리스트 초기화

    # progresses와 speeds 리스트를 동시에 반복
    for p, s in zip(progresses, speeds):
        # 스택이 비어있거나 현재 작업이 스택의 마지막 작업보다 더 오래 걸리는 경우
        if len(Q) == 0 or Q[-1][0] < -((p - 100) // s):
            Q.append([-((p - 100) // s), 1])  # 새로운 작업을 스택에 추가
        else:
            Q[-1][1] += 1  # 현재 작업을 스택의 마지막 작업에 추가

    # 각 작업이 완료되는데 필요한 일 수를 담은 리스트 반환
    return [q[1] for q in Q]
```

## 💡 느낀점 or 기억할정보
* 30을 100으로 만들려면 3일이 필요
  * 근데 여기서 (100-30)//30은 2가 되는데 100을 넘기 위해서는 3이 되어야 한다
  * 이유는 // 는 내림하기 때문으로 -((30 - 100) // 30)을 해준다
  * 음수에서 내림은 절대값이 커지기 때문 즉, -2.3에서 내림하면 -3이 된다
다른 방법으로는 import math 하고 math.ceil(2.3) 하면 된다 하지만 위에가 더 편함