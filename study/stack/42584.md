# 주식가격

## 💡문제
```
초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.

제한사항
* prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.
* prices의 길이는 2 이상 100,000 이하입니다.

입출력 예
prices	         return
[1, 2, 3, 2, 3]	 [4, 3, 1, 1, 0]
```

## 💡알고리즘 설계
* 첫번째
  * 1, 2, 3, 2, 3 이라면
  * 1확인
    * 2 3 2 3 차례대로 검사하면서 1보다 것을 찾을 때까지 개수 계산
    * 4
  * 2확인
    * 3 2 3 차례대로 검사하면서 2보다 것을 찾을 때까지 개수 계산
    * 3
  * 3확인
    * 2 3 차례대로 검사하면서 3보다 것을 찾을 때까지 개수 계산
    * 1 (2만 작음)
  * 이걸 반복

* 두번째
  * 1, 2, 3, 2, 3 이라면 각 돈이 떨어지지 않는다는 가정하에 계산
    * 4, 3, 2, 1, 0 로 초기화
    * s=[0] 순화하면서 아직 가격이 떨어지지 않은 것들에 대해서 넣음
  * s=[0], progresses[0]=1 progresses[1]=2 비교
    * 값이 떨어지지 않으므로 s=[0,1]
  * s=[0,1], progresses[1]=2 progresses[2]=3 비교
    * 값이 떨어지지 않으므로 s=[0,1,2]
  * s=[0,1,2], progresses[2]=3 progresses[3]=2 비교
    * 값이 떨어지므로 s.pop() answer[1]=3(현재 인데스)-2(비교 스택 인덱스)
    * progresses[1]=2 progresses[3]=2비교 값이 안떨어지므로 s=[0,1,3]
  * s=[0,1,3], progresses[3]=2 progresses[4]=3 비교
    * 값이 안떨어진다

## 💡코드

```python
# 첫번째

# 하나의 원소를 잡고 해당 원소부터 앞에 있는 가격들과 비교하여 유지된 기간을 계산하는 함수입니다.
# prices: 가격을 담은 리스트

def solution(prices):
    # 결과를 담을 리스트를 초기화합니다.
    answer = []
    
    # prices 리스트를 순회합니다.
    for i in range(len(prices)):
        # 유지된 기간을 세기 위한 변수를 초기화합니다.
        cnt = 0
        # 현재 원소부터 그 다음 원소들까지 반복합니다.
        for k in range(i+1, len(prices)):
            # 가격이 떨어지면 해당 시점까지의 기간을 세고 반복문을 종료합니다.
            cnt += 1
            if prices[k] < prices[i]:
                break
        # 유지된 기간을 결과 리스트에 추가합니다.
        answer.append(cnt)
    
    return answer

#두번째

# 전부 가격이 떨어지지 않는다는 가정하에 초기화하고 가격이 떨어지는 부분을 찾으면 해당 기간을 계산하여 값을 변경하는 함수입니다.
# prices: 가격을 담은 리스트

def solution(prices):
    # 결과를 담을 리스트를 초기화합니다. 가격의 개수만큼 초기값으로 설정합니다.
    answer = [i for i in range(len(prices)-1, -1, -1)]
    
    # 인덱스를 담을 스택을 초기화합니다. 초기값은 0을 가지고 있습니다.
    s = [0]
    
    # prices 리스트를 순회합니다.
    for i in range(1, len(prices)):
        # 스택이 비어있지 않고, 스택의 가장 위에 있는 인덱스의 가격이 현재 인덱스의 가격보다 크다면
        while s and prices[s[-1]] > prices[i]:
            # 스택에서 pop하여 그 인덱스의 가격이 떨어진 시점까지의 기간을 계산하고 결과 리스트에 반영합니다.
            answer[s[-1]] = i - s[-1]
            s.pop()
        # 현재 인덱스를 스택에 추가합니다.
        s.append(i)
    
    return answer


```

## 💡시간복잡도

## 💡 틀린 이유

## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
떨어지지않는다는 가정하에 초기화를 하고 떨어지는 부분을 찾아서 값을 변경하는 방법
이때 아직 값이 유지되고 있는 것을 스택에 저장하여 관리한다