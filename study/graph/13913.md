# 숨바꼭질 4

## 💡**문제 분석 요약**

시간제한 2초
메모리 제한 512MB
 
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 
수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 
순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다

출력

첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다
둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다

## 💡**알고리즘 설계**

* 두개의 배열이 필요하다
  * 최소 시간을 구하기 위한 배열
    * 다음 정점에 현재 정점에 +1을 해준다(이동하면서 1씩 늘어나기 때문)
  * 해당 정점을 선택한 정점을 저장할 배열
    * 정점들은 한번씩만 방문이 가능하다
    * 저번에도 말했듯이 이미 방문한 곳으로 간다는 것은 이미 그 경로는 최소 경로가 아니라는 것이다
    * 그러니 각 정점은 부모 정점은 하나씩 가지고 있다 그러니 배열에 부모 정점을 저장해 놓은다
* 목적지에 도착하면 최소 시간을 출력하고 부모 정점을 확인하면서 저장하면 거꾸로 저장이 된다 이를 역순하여 출력한다

## 💡코드

```python

import sys
from collections import deque

max_num = 100001

def bfs(v):
    # 초기화
    queue = deque()
    queue.append(v)
    visited[v] = 1

    # BFS 탐색
    while queue:
        n = queue.popleft()
        # 도착 지점에 도달한 경우
        if n == K:
            while parent[n] != -1:
                result.append(n)
                n = parent[n]
        # 인접한 위치 탐색
        for i in [n - 1, n + 1, n * 2]:
            # 범위 확인 및 방문 여부 확인
            if 0 <= i < max_num and visited[i] == 0:
                queue.append(i)
                visited[i] = visited[n] + 1
                parent[i] = n

# 시작 지점과 도착 지점 입력 받기
N, K = map(int, sys.stdin.readline().strip().split())

# 방문 여부, 부모 노드, 결과 저장을 위한 리스트 초기화
visited = [0 for _ in range(max_num)]
parent = [-1 for _ in range(max_num)]
result = []

# BFS 호출
bfs(N)

# 결과 출력
result.reverse()
print(visited[K] - 1)
print(N, *result)

```

## 💡시간복잡도
O(V + E) 여기서 V는 정점의 수이고, E는 간선의 수

## 💡 틀린 이유
처음에 각 정점은 하나씩 선택된다고 생각해놓고는
이동할 때마다 들리는 각 정점을 저장하고 큐에 추가해줬다 배열을 만들고 전달하는 방법이 반복되다 보니 시간초과가 발생한 것 같다


## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
이동할 때 [n - 1, n + 1, n * 2] 이런 리스트를 만들어서 for문을 돌리면 되는데 생각을 못했다,,