# 숨바꼭질 3

## 💡**문제 분석 요약**

시간제한 2초
메모리 제한 512MB

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고,
동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 

수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

출력

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

## 💡**알고리즘 설계**

* 방문 배열을 0~100000까지 만들어주고 -1로 초기화 해줬다
  * -1로 한 이유는 순간이동이 0초이기 때문
* 이동하는 방향은 왼쪽 오른쪽 순간이동(2배)이다
  * 1초 왼쪽, 오른쪽
  * 0초 2배
* 0초인 순간이동이 우선시가 되어야 하기 때문에 0초인 부분은 먼저 큐에 넣어준다
* 큐에서 정점을 꺼내서 해당 정점에서 여러 방향으로 이동하고 방문 배열에 +1 or +0을 해준다
* 목적 정점에 도달할 때까지 반복한다

## 💡코드

```python

import sys
from collections import deque

def bfs(v):
    # 큐를 초기화하고 시작 노드를 추가
    queue = deque()
    queue.append(v)
    
    # 시작 노드의 방문 여부를 0으로 표시
    visited[v] = 0

    while queue:
        # 큐에서 노드를 하나 꺼내옴
        n = queue.popleft()
        
        # 목표 노드에 도달하면 방문한 거리를 반환하고 종료
        if n == K:
            return visited[n]
        
        # 현재 노드의 2배인 노드에 대한 처리
        if n * 2 < max_num and (visited[n * 2] == -1 or visited[n * 2] >= visited[n]):
            queue.append(n * 2)
            visited[n * 2] = visited[n] + 0  # 방문한 거리를 갱신
        
        # 현재 노드에서 1을 뺀 노드에 대한 처리
        if 0 <= n - 1 and (visited[n - 1] == -1):
            queue.append(n - 1)
            visited[n - 1] = visited[n] + 1  # 방문한 거리를 갱신
        
        # 현재 노드에서 1을 더한 노드에 대한 처리
        if n + 1 < max_num and (visited[n + 1] == -1):
            queue.append(n + 1)
            visited[n + 1] = visited[n] + 1  # 방문한 거리를 갱신

# 입력 받기
N, K = map(int, sys.stdin.readline().strip().split())

# 최대 노드 수 설정
max_num = 100001

# 방문 여부를 나타내는 리스트 초기화
visited = [-1 for _ in range(max_num)]

# BFS 실행 및 결과 출력
print(bfs(N))

```

## 💡시간복잡도
O(V + E) 여기서 V는 정점의 수이고, E는 간선의 수

## 💡 틀린 이유
2 7을 입력했을 때
[2, 1, 0, 1, 0, 1, 1, 2, 0, 1, 1, -1, 1, -1]
인덱스 8인 곳에서 -1로 이동하는게 최소 거리인데 이미 2이기 때문에 이동할 수 없더(-1이면 이동하게 했기 때문) 그래서 무슨 문제인가 싶었는데 순간이동인 0이 우선시 되어야 하기때문에 큐에 먼저 넣고 꺼내야 하는 것!


## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
여러방향으로 이동할 때 우선순위가 먼저인 것은 먼저 큐에 넣어줘야 한다는 것!