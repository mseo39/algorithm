# 연구소 3

## 💡문제 분석 요약
```
시간제한 0.25초
메모리제한 512MB

인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 
바이러스는 활성 상태와 비활성 상태가 있다. 가장 처음에 모든 바이러스는 비활성 상태이고, 
활성 상태인 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다. 
승원이는 연구소의 바이러스 M개를 활성 상태로 변경하려고 한다.
연구소는 크기가 NxN인 정사각형으로 나타낼 수 있으며, 정사각형은 1x1 크기의 정사각형으로 나누어져 있다. 
연구소는 빈 칸, 벽, 바이러스로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 
활성 바이러스가 비활성 바이러스가 있는 칸으로 가면 비활성 바이러스가 활성으로 변한다.

예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스의 위치이다.
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 0 0 2

M = 3이고, 바이러스를 아래와 같이 활성 상태로 변경한 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 
벽은 -, 비활성 바이러스는 *, 활성 바이러스는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.

* 6 5 4 - - 2
5 6 - 3 - 0 1
4 - - 2 - 1 2
3 - 2 1 2 2 3
2 2 1 0 1 - -
1 - 2 1 2 3 4
0 - 3 2 3 4 *

시간이 최소가 되는 방법은 아래와 같고, 4초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.
0 1 2 3 - - 2
1 2 - 3 - 0 1
2 - - 2 - 1 2
3 - 2 1 2 2 3
3 2 1 0 1 - -
4 - 2 1 2 3 4
* - 3 2 3 4 *
연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.

입력
첫째 줄에 연구소의 크기 N(4 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.
둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 
0은 빈 칸, 1은 벽, 2는 비활성 바이러스의 위치이다. 2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.

출력
연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 
바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.
```
## 💡문제 정리
* 가장 처음에 모든 바이러스가 비활성 상태이다
* 활성 상태인 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며 1초 걸린다
  * 비활성 상태인 바이러스를 만나면 바이러스가 활성화 된다
  * ⭐단 주의할 점은 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구하는 것이지 비활성을 활성상태로 변하는 것은 포함되지 않는다
  * 따라서 이동은 하지만 갱신을 하면 안된다
* 승원이는 연구소의 바이러스 M개를 활성 상태로 변경하려고 한다
* 빈칸:0 벽:1 바이러스:2

## 💡알고리즘 설계
* 바이러스 위치를 담은 일차원 배열을 만든다
* dfs를 사용하여 바이러스 중에서 M개를 선택한다
* 선택 후, 선택한 바이러스를 bfs로 퍼트려본다
  * 이동하면서 1초 증가 시키고 최대값을 갱신한다
  * 퍼트린 뒤, 모든 빈칸이 전부 바이러스로 감염되었으면 다른 경우의 시간보다 적은 시간이 걸렸다면 갱신한다

## 💡코드

```python
import sys
from collections import deque

def bfs():
    global result
    max_num = 0  # 특정 시작점으로부터 모든 빈 칸이 감염되는 데 필요한 최대 시간
    cnt = 0  # 감염된 셀의 수를 세는 변수
    q = deque()  # BFS 순회에 사용되는 큐
    A_visited = [[0 for _ in range(N)] for _ in range(N)]  # 방문한 셀을 추적하기 위한 행렬
    # 감염된 셀의 시작점을 초기화
    for i in range(len(birus)):
        if visited[i] == 1:
            A_visited[birus[i][0]][birus[i][1]] = -1  # 감염된 셀로 표시
            q.append([birus[i][0], birus[i][1], 0])  # 거리 0으로 감염된 셀을 큐에 추가

    while q:
        x, y, d = q.popleft()  # 셀을 큐에서 빼옴
        if max_num >= result:  # 최대 시간이 현재 결과보다 크거나 같으면 종료
            return
        for i in location:  # 인접한 셀 확인
            n_x = x + i[0]
            n_y = y + i[1]
            if 0 <= n_x < N and 0 <= n_y < N and A_visited[n_x][n_y] == 0 and A[n_x][n_y] != 1:
                if A[n_x][n_y] == 0:  # 셀이 비어 있으면
                    q.append([n_x, n_y, d + 1])  # 업데이트된 거리로 큐에 추가
                    A_visited[n_x][n_y] = d + 1  # 현재 거리로 셀을 방문 처리
                    max_num = max(max_num, d + 1)  # 필요한 최대 시간을 업데이트
                    cnt += 1  # 감염된 셀 수 증가
                else:
                    q.append([n_x, n_y, d + 1])  # 감염된 셀을 업데이트된 거리로 큐에 추가
                    A_visited[n_x][n_y] = d + 1  # 현재 거리로 셀을 방문 처리

    if A_cnt == cnt:  # 모든 빈 칸이 감염되었을 경우
        result = min(result, max_num)  # 필요한 최소 시간을 결과에 업데이트

def dfs(v, depth):
    if depth == M:  # 필요한 감염된 셀의 수에 도달했을 경우
        bfs()  # 최소 시간을 찾기 위해 BFS 수행
        return
    for i in range(v, len(birus)):
        if visited[i] == 0:  # 방문하지 않은 셀인 경우
            visited[i] = 1  # 셀을 방문으로 표시
            dfs(i + 1, depth + 1)  # 재귀적으로 가능한 모든 경우를 탐색
            visited[i] = 0 

location = [[1, 0], [0, 1], [-1, 0], [0, -1]]  # 이동 가능한 방향 (상, 하, 좌, 우)
N, M = map(int, sys.stdin.readline().strip().split())  # 격자 크기와 필요한 감염된 셀의 수 입력
A = [list(map(int, sys.stdin.readline().strip().split())) for _ in range(N)]  # 격자 정보 입력
result = N * N  # 초기 결과를 최대값으로 설정
A_cnt = 0  # 빈 칸의 수
birus = []  # 감염된 셀의 위치를 저장하는 리스트
for x in range(N):
    for y in range(N):
        if A[x][y] == 0:  # 빈 칸인 경우
            A_cnt += 1  # 빈 칸 수 증가
        if A[x][y] == 2:  # 감염된 셀인 경우
            birus.append([x, y])  # 위치를 리스트에 추가
visited = [0 for _ in range(len(birus))]  # 감염된 셀을 추적하기 위한 리스트
dfs(0, 0)  # 감염된 셀의 조합을 찾기 위해 DFS 수행
print(-1 if result == N * N else result)  # 결과 출력

```

## 💡시간복잡도

## 💡 틀린 이유


## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
골3부터는 dfs bfs 둘 다 쓰는 문제들이 나온다 재밌~ 풀면 넘나리 뿌듯
그리고 문제 제대로 해석하기 이 문제는 설명이 좀 거지 같았다,,ㅎㅎ