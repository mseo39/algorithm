# 나이트의 이동


## 💡**문제 분석 요약**

시간제한 1초
메모리 제한 256MB

체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다
나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇번 움직이면 이 칸으로 이동할 수 있을까?

입력
입력의 첫째 줄에는 테스트케이스의 개수가 주어진다
각 테스트 케이스는 세 줄로 이루어져 있다. 
첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 
체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, ..., l-1} × {0, ..., l-1}로 나타낼 수 있다. 
둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.

출력
각 테스트케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.

## 💡**알고리즘 설계**

* 전형적인 bfs 문제이다
* 먼저 나이트가 이동할 수 있는 경로들을 정리한다
  * [[-2, -1], [-2, 1], [-1, 2], [-1, -2], [1, -2], [1, 2], [2, -1], [2, 1]]
* 방문할 때마다 +1을 해준다
  * 여기서 방문할 때 방문하려는 곳이 0인지 확인해야 한다
* 탐색중에 목적 좌표에 도달하면 return한다

## 💡코드

```python

import sys
from collections import deque

# 나이트가 이동할 수 있는 8가지 방향을 표현하는 상대 좌표의 리스트
distance = [[-2, -1], [-2, 1], [-1, 2], [-1, -2], [1, -2], [1, 2], [2, -1], [2, 1]]

def bfs():
    # 출발지와 목적지가 동일한 경우, 이동 횟수는 0이다.
    if s_x == b_x and s_y == b_y:
        return 0
    
    # BFS 탐색을 위한 큐 초기화
    queue = deque()
    queue.append([s_x, s_y])

    # BFS 탐색
    while queue:
        # 현재 위치를 큐에서 꺼냄
        n_x, n_y = queue.popleft()
        
        # 현재 위치에서 가능한 8가지 방향에 대해 탐색
        for i in distance:
            x = n_x + i[0]
            y = n_y + i[1]
            
            # 새로운 위치가 체스판 내부에 있고, 방문하지 않은 경우
            if 0 <= x < l and 0 <= y < l and map_list[x][y] == 0:
                # 새로운 위치를 큐에 추가하고, 해당 위치의 값을 현재 위치의 값 + 1로 업데이트
                queue.append([x, y])
                map_list[x][y] = map_list[n_x][n_y] + 1
            
            # 목적지에 도달한 경우, 이동 횟수를 반환
            if x == b_x and y == b_y:
                return map_list[x][y]

# 테스트케이스 개수 입력
for _ in range(int(sys.stdin.readline().strip())):
    # 체스판 크기 입력
    l = int(sys.stdin.readline())
    
    # 출발지와 목적지 입력
    s_x, s_y = map(int, sys.stdin.readline().strip().split())
    b_x, b_y = map(int, sys.stdin.readline().strip().split())
    
    # 각 테스트케이스에 대해 BFS 탐색을 수행하고 결과 출력
    map_list = [[0 for _ in range(l)] for _ in range(l)]
    print(bfs())

```

## 💡시간복잡도
정점 : O(N^2) - 정점의 개수
간선 : O(N^2 x 8) - 정점에 붙을 수 있는 간선 개수 = 8개 여기다 정점 개수 곱함

O(N^2)

O(V+E)이기 때문

## 💡 틀린 이유



## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
1. 인접한 곳을 탐색 and 최소 -> BFS문제! 라는 것을 기억하자
2. 전 문제들은 0이 아닌 곳만 방문하라는 식의 조건을 줬는데 이번 문제에서는 그런 내용이 없었는데도 불구하고 그 조건문을 작성해야 문제가 풀렸다 그래서 생각해봤는데 내가 a라는 곳을 탐색하여고 봤는데 0이 아니라 이미 방문한 곳이라면 똑같은 경로를 탐색하게 된다 즉, 이미 최소가 아니라는 뜻이다 (그 전 경로가 이미 탐색했고 그 전 경로와 현재 경로를 봤을 때) 그러니 그 경로는 바로 끝내는 것!