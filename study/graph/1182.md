# 부분수열의 합

## 💡**문제 분석 요약**

시간제한 2초
메모리 제한 256MB

N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 정수의 개수를 나타내는 N과 정수 S가 주어진다. (1 ≤ N ≤ 20, |S| ≤ 1,000,000) 
둘째 줄에 N개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다.

출력
첫째 줄에 합이 S가 되는 부분수열의 개수를 출력한다.

## 💡**알고리즘 설계**

* 내가 현재 선택한 원소의 인덱스 +1을 해서 재귀호출하고 인덱스+1한 부분부터 원소를 넣는다
  * 

## 💡코드

```python

import sys

def solution(v):
    global count
    
    # 현재 부분집합(arr)의 합이 목표 값(S)과 일치하면 count 증가
    if len(arr)!=0 and sum(arr)==S:
        count+=1
    
    # 현재 인덱스(v)부터 배열 끝까지 반복
    for i in range(v,N):
        arr.append(N_list[i])  # 현재 원소를 부분집합에 추가
        solution(i+1)          # 재귀 호출: 다음 원소로 진행
        arr.pop()              # 백트래킹: 현재 원소를 부분집합에서 제거

# 입력 받기
N,S=map(int, sys.stdin.readline().strip().split())
N_list = list(map(int, sys.stdin.readline().strip().split()))
arr = []    # 부분집합을 저장할 리스트
count=0    # 목표 값을 만족하는 부분집합의 개수를 세는 변수
solution(0) # 부분집합 생성 함수 호출
print(count)  # 결과 출력

```

## 💡시간복잡도
각 원소에 대해 선택하거나 선택하지 않는 두 가지 선택이 있음.
재귀 호출을 통해 다음 원소로 이동.
이 때, 각 원소에 대해 두 가지 선택이 있고, 재귀 호출을 통해 다음 원소로 이동하므로 재귀 호출이 깊이 N에 걸쳐서 일어납니다.

각 단계에서는 현재 인덱스 i부터 배열의 끝까지 반복문을 수행합니다. 따라서 반복문의 횟수는 최대 (N-i)가 됩니다.

이제 전체 시간 복잡도를 계산해보겠습니다. 재귀 호출이 2^N개 발생

## 💡 틀린 이유



## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
