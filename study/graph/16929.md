# 알고스팟

## 💡**문제 분석 요약**

시간제한 2초
메모리제한 512MB

Two Dots는 Playdots, Inc.에서 만든 게임이다. 게임의 기초 단계는 크기가 NxM인 게임판 위에서 진행된다.

각각의 칸은 색이 칠해진 공이 하나씩 있다. 이 게임의 핵심은 같은 색으로 이루어진 사이클을 찾는 것이다.

다음은 위의 게임판에서 만들 수 있는 사이클의 예시이다.

점 k개 d1, d2, ..., dk로 이루어진 사이클의 정의는 아래와 같다.

모든 k개의 점은 서로 다르다. 
k는 4보다 크거나 같다.
모든 점의 색은 같다.
모든 1 ≤ i ≤ k-1에 대해서, di와 di+1은 인접하다. 또, dk와 d1도 인접해야 한다. 
두 점이 인접하다는 것은 각각의 점이 들어있는 칸이 변을 공유한다는 의미이다.
게임판의 상태가 주어졌을 때, 사이클이 존재하는지 아닌지 구해보자.

입력
첫째 줄에 게임판의 크기 N, M이 주어진다. 
둘째 줄부터 N개의 줄에 게임판의 상태가 주어진다. 게임판은 모두 점으로 가득차 있고, 
게임판의 상태는 점의 색을 의미한다. 점의 색은 알파벳 대문자 한 글자이다.

출력
사이클이 존재하는 경우에는 "Yes", 없는 경우에는 "No"를 출력한다.

#### 문제 정리

* 서로 다른 점들의 개수가 4개 이상이고 사이클을 이뤄야한다

#### 문제 분석
* 서로 다른 점이기 때문에 현재 만들고 있는 배열에 포함되어있는지 검사해야 한다
* 길이가 4이상이어야 한다
* 사이클을 만드려면 처음 원소와 마지막 원소가 같아야 한다


## 💡**알고리즘 설계**

* 각 점들을 모두 방문하면서 사이클이 있는 검사한다
  * 방문한 곳을 다시 검사하는 이유는 방문한 곳에서도 점 몇개를 빼면 사이클을 만들 수 있는 경우가 있기 때문
* 상하좌우로 이동하고 만들고 중복되지 않는지 검사한다
* 길이가 4이상이고 처음 좌표와 현재 넣으려는 좌표가 같다면 사이클이기 때문에 True를 반환한다


## 💡코드

```python

import sys

# 이동 방향을 정의하는 리스트
location = [[1, 0], [0, 1], [-1, 0], [0, -1]]

def dfs(x, y, v):
    # 네 방향으로 이동
    for i in location:
        b_x = x + i[0]
        b_y = y + i[1]
        
        # 범위 내에 있고 같은 값인 경우
        if 0 <= b_x < N and 0 <= b_y < M and map_list[b_x][b_y] == v:
            # 사이클이 형성되고, 사이클이 최소 4개의 좌표를 포함하며 시작 좌표와 일치하는 경우
            if len(arr) >= 4 and arr[0][0] == b_x and arr[0][1] == b_y:
                return True
            
            # 방문한 좌표를 배열에 추가하고 재귀 호출
            if [b_x, b_y] not in arr:
                arr.append([b_x, b_y])
                if dfs(b_x, b_y, v):
                    return True
                arr.pop()
    
    return False

# 입력 받기
N, M = map(int, sys.stdin.readline().strip().split())
map_list = [sys.stdin.readline().strip() for _ in range(N)]
arr = []  # 현재 탐색 중인 좌표들을 저장하는 배열
chk = 0

# 모든 좌표에 대해 탐색 시작
for x in range(N):
    for y in range(M):
        arr.append([x, y])
        
        # DFS를 통해 사이클 확인
        if dfs(x, y, map_list[x][y]):
            chk = 1
            break
        
        arr.pop()

# 결과 출력
if chk:
    print("Yes")
else:
    print("No")

```

## 💡시간복잡도
O(V + E) 여기서 V는 정점의 수이고, E는 간선의 수
O(N^2)

## 💡 틀린 이유


## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보