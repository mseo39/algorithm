# BFS 스페셜 저지

## 💡**문제 분석 요약**

시간제한 2초
메모리제한 512MB

BOJ에서 정답이 여러가지인 경우에는 스페셜 저지를 사용한다. 스페셜 저지는 유저가 출력한 답을 검증하는 코드를 통해서 정답 유무를 결정하는 방식이다. 
오늘은 스페셜 저지 코드를 하나 만들어보려고 한다.

정점의 개수가 N이고, 정점에 1부터 N까지 번호가 매겨져있는 양방향 그래프가 있을 때, BFS 알고리즘은 다음과 같은 형태로 이루어져 있다.

1. 큐에 시작 정점을 넣는다. 이 문제에서 시작 정점은 1이다. 1을 방문했다고 처리한다.
2. 큐가 비어 있지 않은 동안 다음을 반복한다.
  1. 큐에 들어있는 첫 정점을 큐에서 꺼낸다. 이 정점을 x라고 하자.
  2. x와 연결되어 있으면, 아직 방문하지 않은 정점 y를 모두 큐에 넣는다. 모든 y를 방문했다고 처리한다.

2-2단계에서 방문하지 않은 정점을 방문하는 순서는 중요하지 않다. 따라서, BFS의 결과는 여러가지가 나올 수 있다.

트리가 주어졌을 때, 올바른 BFS 방문 순서인지 구해보자.

입력

첫째 줄에 정점의 수 N(2 ≤ N ≤ 100,000)이 주어진다. 
둘째 줄부터 N-1개의 줄에는 트리의 간선 정보가 주어진다. 
마지막 줄에는 BFS 방문 순서가 주어진다. 
BFS 방문 순서는 항상 N개의 정수로 이루어져 있으며, 1부터 N까지 자연수가 한 번씩 등장한다.

출력

입력으로 주어진 BFS 방문 순서가 올바른 순서면 1, 아니면 0을 출력한다.

#### 문제 정리

* 양방향 트리가 주어졌을 때 올바른 BFS 방문 순서인지 확인한다

#### 문제 분석
* 깊이에 따라 순서가 맞는지 확인
예를 들어
```
1: 2 3 4
2: 5 6
3: 7
ans=1 2 3 4 5 6 7
idx=1

1의 자식 2,3 == ans[idx:idx+len(1의 자식)]=2,3
idx+=len(1의 자식)
2의 자식 5,6 == ans[idx:idx+len(2의 자식)]=5,6
idx+=len(2의 자식)
.
.
.

여기서 주의할 점은 큐에 넣을 때 ans[idx:idx+len(2의 자식)]로 갱신해야 한다
그 이유는 정점을 꺼내는 순서에 따라 뒤에 순서가 달라지기 때문
자세한것은 틀린 이유에
```

## 💡**알고리즘 설계**

* 시작 정점을 큐에 추가하고 방문 표시를 함.
* 큐가 비어있지 않은 동안 반복:
  * 큐에서 정점을 꺼내고, 이 정점과 연결된 아직 방문하지 않은 정점들을 확인.
  * 현재 정점의 자식들과 주어진 BFS 방문 순서와 일치하는지 확인.
  * 일치하면 자식들을 큐에 추가하고, 다음 방문 순서의 시작 인덱스를 업데이트.
  * 일치하지 않으면 0을 반환하고 종료.
* 모든 정점을 방문하고 일치하면 1을 반환.


## 💡코드

```python
from sys import stdin
from collections import deque
input = stdin.readline

def bfs():
    # 큐 초기화
    queue = deque()
    queue.append(1)  # 시작 정점 1을 큐에 넣음
    visited[1] = 1  # 시작 정점 방문 표시
    idx = 1  # BFS 방문 순서를 나타내는 인덱스 초기화

    while queue:
        x = queue.popleft()  # 큐에서 정점을 하나 꺼냄
        children = []  # 현재 정점의 자식들을 저장할 리스트 초기화

        # 현재 정점과 연결된 정점들에 대해 반복
        for i in link[x]:
            if visited[i] == 0:  # 아직 방문하지 않은 정점인 경우
                visited[i] = 1  # 방문 표시
                children.append(i)  # 자식으로 추가

        c_len = len(children)  # 현재 정점의 자식 개수
        tmp = ans[idx : idx + c_len]  # BFS 방문 순서와 일치하는 부분을 임시로 추출

        # BFS 방문 순서와 현재 정점의 자식들이 일치하는지 확인
        if set(tmp) == set(children):
            queue.extend(tmp)  # 일치하면 자식들을 큐에 추가하여 계속해서 탐색
            idx += c_len  # 다음 방문 순서의 시작 인덱스 업데이트
        else:
            return 0  # 일치하지 않으면 0을 반환하고 종료

    return 1  # 모든 정점을 방문하고 일치하면 1을 반환
        
# 정점의 개수 입력 받기
N = int(input())

# 간선 정보를 저장하는 리스트 초기화
link = [[] for i in range(N + 1)]

# 정점 간의 연결 정보 입력 받기
for i in range(N - 1):
    a, b = map(int, input().split())
    link[a].append(b)
    link[b].append(a)

# BFS 방문 순서 입력 받기
ans = list(map(int, input().split()))

# 시작 정점이 1인 경우 BFS 실행 및 결과 출력
if ans[0] == 1:
    print(bfs())
else:
    print(0)

```

## 💡시간복잡도
O(V + E) 여기서 V는 정점의 수이고, E는 간선의 수
O(N)

## 💡 틀린 이유
```python
#수정후
if set(tmp) == set(children):
    queue.extend(tmp)  # 일치하면 자식들을 큐에 추가하여 계속해서 탐색
    idx += c_len  # 다음 방문 순서의 시작 인덱스 업데이트
#수정전
if set(tmp) == set(children):
    queue.extend(children)  # 일치하면 자식들을 큐에 추가하여 계속해서 탐색
    idx += c_len  # 다음 방문 순서의 시작 인덱스 업데이트
```
왜 틀렸는지를 한참을 찾았다,,,
이유는 위 코드 때문이다 수정 후와 수전 전을 보면 queue에 extend하는 변수가 다른 것을 알 수 있다
chidren에 정점을 넣을 때는 순서대로 저장이 된다 즉 1의 자식이 [2,3]이라면 2,3 순서대로 저장을 하고 순서가 다를 수 있기 때문에 set으로 바꿔서 비교를 한다
예를 들어보면
```
7
1 2
1 3
2 4
2 5
3 6
3 7
1 3 2 6 7 4 5
```
일 때 1의 자식으로 children=[2,3]이 된다 그리고 큐에 extend하니 큐 = [2,3]이 된다
큐에서 를 꺼내면 children=[4,5]가 되고 tmp=[6,7]이 되어 틀린다고 한다
즉, 여기서 문제는 1 3 2 6 7 4 5 순서를 보면 2가 아니라 3을 먼저 꺼내서 비교해야
[2, 3] [3, 2], [6, 7] [6, 7], [4, 5] [4, 5] 로 정답이 된다
그래서 큐에는 children이 아닌 입력을로 주어진 방문 순서를 따라야 한다는 것이다


## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
손으로 알고리즘 제대로 짜보기