# 숨바꼭질

## 💡**문제 분석 요약**

시간제한 2초
메모리제한 512MB

서울 지하철 2호선은 다음과 같이 생겼다
지하철 2호선에는 51개의 역이 있고, 역과 역 사이를 연결하는 구간이 51개 있다. 
즉, 정점이 51개이고, 양방향 간선이 51개인 그래프로 나타낼 수 있다. 2호선은 순환선 1개와 2개의 지선으로 이루어져 있다. 
한 역에서 출발해서 계속 가면 다시 출발한 역으로 돌아올 수 있는 노선을 순환선이라고 한다. 
지선은 순환선에 속하는 한 역에서 시작하는 트리 형태의 노선이다.

두 역(정점) 사이의 거리는 지나야 하는 구간(간선)의 개수이다. 
역 A와 순환선 사이의 거리는 A와 순환선에 속하는 역 사이의 거리 중 최솟값이다.

지하철 2호선과 같은 형태의 노선도가 주어졌을 때, 각 역과 순환선 사이의 거리를 구해보자.

입력
첫째 줄에 역의 개수 N(3 ≤ N ≤ 3,000)이 주어진다. 
둘째 줄부터 N개의 줄에는 역과 역을 연결하는 구간의 정보가 주어진다. 
같은 구간이 여러 번 주어지는 경우는 없고, 역은 1번부터 N번까지 번호가 매겨져 있다. 
임의의 두 역 사이에 경로가 항상 존재하는 노선만 입력으로 주어진다.

출력
총 N개의 정수를 출력한다. 
1번 역과 순환선 사이의 거리, 2번 역과 순환선 사이의 거리, ..., N번 역과 순환선 사이의 거리를 공백으로 구분해 출력한다.

## 💡**알고리즘 설계**

DFS (깊이 우선 탐색):

* dfs 함수는 재귀적으로 그래프를 탐색하며 사이클을 찾습니다.
  * 시작 정점에서 출발하여 각 정점을 방문하고, 방문한 정점들을 스택에 저장합니다.
  * 스택에 쌓인 정점 중에서 시작 정점으로 되돌아오고, 사이클의 길이가 2 이상인 경우 True를 반환합니다.
    * 여기서 깊이를 2이상인 경우로 한것은 1 - 2 - 1이 되는 경우를 막기 위해서다
  * 만약 사이클을 찾지 못하면 False를 반환하며, 스택에서 방문한 정점을 하나씩 제거합니다.


* BFS (너비 우선 탐색):
  * 여기서 핵심은 순환에 해당하는 정점들을 먼저 큐에 넣는다는 것이다
    * 그렇게하면 다른 정점에 먼저 도착한 것이 거리가 되기 때문이다
    * 각 정점에서 순환에 해당되는 것을 찾아 이동하는 것보다 빠르다
  * bfs 함수는 DFS를 통해 찾은 사이클을 기반으로 각 정점에서 모든 다른 정점까지의 최단 거리를 계산합니다.
  * BFS를 사용하여 최단 거리를 계산하고, 결과를 출력합니다.

* 전체 흐름:
  * 정점의 개수와 간선 정보를 입력 받고, 그래프를 생성합니다.
  * DFS를 통해 사이클을 찾아내면 그 사이클을 기반으로 BFS를 이용하여 최단 거리를 계산합니다.
  * 최단 거리를 출력합니다.

## 💡코드

```python

import sys
from collections import deque
sys.setrecursionlimit(100000)

def dfs(v, dept):

    for i in N_list[v]:
        if arr[0] == i and dept > 1:
            return True  # 시작 정점으로 되돌아왔고, 사이클의 길이가 2 이상인 경우 True 반환
        if i not in arr:
            arr.append(i)
            if dfs(i, dept + 1):
                return True  # 재귀 호출 결과가 True인 경우 True 반환
            arr.pop()

def bfs():
    chk = [-1 for _ in range(N + 1)]  # 각 정점까지의 최단 거리를 저장하는 리스트 초기화
    queue = deque()

    for i in arr:
        queue.append(i)
        chk[i] = 0

    while queue:
        n = queue.popleft()
        for i in N_list[n]:
            if chk[i] == -1:
                queue.append(i)
                chk[i] = chk[n] + 1  # 이전 정점까지의 최단 거리에서 1을 더해 현재 정점까지의 최단 거리 갱신
    print(*chk[1:])  # 최단 거리 출력

N = int(sys.stdin.readline())
N_list = [[] for _ in range(N + 1)]  # 각 정점에 연결된 정점들을 저장하는 리스트 초기화
for _ in range(N):
    x, y = map(int, sys.stdin.readline().strip().split())
    N_list[x].append(y)
    N_list[y].append(x)

arr = []

for i in range(1, N + 1):
    arr.append(i)
    if dfs(i, 0):  # dfs 함수 호출하여 사이클 여부 확인
        break
    arr.pop()

bfs()  # bfs 함수 호출하여 최단 거리 출력

```

## 💡시간복잡도
O(V + E)입니다. 여기서 V는 정점의 수이고, E는 간선의 수

N^2

## 💡 틀린 이유


## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
 사이클을 만들 때 dept도 사용할 수 있음을 기억하자

 또 최소 거리를 구할 때 모든 정점에서 순환 정점까지 거리를 구하는 것보다
 
 그 반대로 순환 정점에서 다른 정점에 들릴 때마다 값을 갱신하는게 더 빠르다
 
 즉, 반대로 생각해보는 것도 중요하다