# 💡**문제 분석 요약**

시간제한 2초
메모리 제한 256MB

그래프의 정점의 집합을 둘로 분할하여 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때,
그러한 그래프를 특별히 이분 그래프라 부른다
그래프가 입력으로 주어질 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오

입력
입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K가 주어진다
각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V와 간선의 개수 E가 빈 칸을 사이에 두고 순서대로 주어진다
각 정점에는 1부터 v까지 차례로 번호가 붙어 있다 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데
각 줄에 인접한 두 정점의 번호 u, v (u ≠ v)가 빈칸을 사이에 두고 주어진다

출력
k개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프라면 YES, 아니면 NO를 순서대로 출력한다

# 💡**알고리즘 설계**

* 입력받은 것을 이용하여 양방향 그래프로 만들어준다
* 0~v-1까지 방문하지 않은 곳이라면 탐색해준다
  * 방문 표시는 0, 1, -1로 표현한다
    * 여기서 0은 방문하지 않은 것, 1과 -1은 서로 다른 집합이라는 것을 나타낸다
  * 처음 큐에 넣는 정점은 1이라고 넣으면 인접한 부분은 -1을 넣어준다(다른 집합에 속해야 한다는 것을 표시)
  * 이렇게 인접한 부분에는 현재 정점과 다른 집합이라는 것을 표시하기 위해서 -visited[현재정점]을 넣어줘야한다
  * 그런데 인접한 정점중에 0이 아니고 visited[현재정점]==visited[인접한정점]이라면 인접하지 않운 2개의 집합을 만들 수 없으므로(어떤 집합에 넣든 인접하기 떄문) NO를 출력해야 한다

예시를 들어보자
다음 입력이 들어왔을 때(참고로 코드에는 인덱스 0부터 시작하기 위해 전부 -1을 해줬다)
1
4 4
1 2
2 3
3 4
4 2
만들어지는 그래프는 다음과 같다
v_list=[
    []
    [2,4],
    [3,1,4],
    [4,2],
    [2,3]
]
1. 먼저 1부터 탐색을 해보자
정점 1을 방문했고 처음 방문을 시작한 것을 집합 1로 처리한다 visited [1,0,0,0]
1과 인접한 정점은 2와 4이다 그러므로 visited [1,-1,0,-1]이 된다
2. 그 인접한 정점 중 2를 탐색한다
2와 인접한 정점은 3,1,4이다 여기서 3은 0이고 2는 -1이기 때문에 2에 -를 붙여줘서 3에 1을 넣음으로써 2와 3은 다른 집합에 있어야 함을 표시한다
그 다음 1은 이미 방문했고 2와 다른 집합에 속하므로 패스
그다음 4는 방문했지만 2와 같은 -1 집합에 속해있다 
따라서 인접한 두개의 정점이 같은 집합에 속하게 되므로 NO를 출력해줘야하고

만약에 이 예시와 다르게 처음부터 끝까지 전부 탐색을 끝냈다면 YES를 출력해준다


# 💡코드

```python

import sys
from collections import deque

# 너비 우선 탐색 함수 정의
def bfs(v):
    # 시작 노드를 방문 표시하고 큐에 추가
    visited[v] = 1
    queue = deque()
    queue.append(v)

    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 노드를 추출
        n = queue.popleft()
        # 현재 노드와 연결된 모든 노드에 대해
        for i in v_list[n]:
            # 방문하지 않은 경우 큐에 추가하고 방문 표시
            if visited[i] == 0:
                queue.append(i)
                visited[i] = -visited[n]
            # 이미 방문한 노드일 경우 같은 집합이면 이분 그래프가 아님을 의미하므로 False 반환
            if visited[i] == visited[n]:
                return False
    # 모든 노드에 대한 탐색이 끝났을 때, 이분 그래프임을 의미하는 True 반환
    return True

# 테스트 케이스 개수 입력
for i in range(int(sys.stdin.readline())):
    # 정점의 개수 V와 간선의 개수 E 입력
    V, E = map(int, sys.stdin.readline().strip().split())
    
    # 인접 리스트 초기화
    v_list = [[] for _ in range(V)]
    
    # 방문 여부를 나타내는 배열 초기화
    visited = [0 for _ in range(V)]

    # 간선 정보 입력 및 인접 리스트에 저장
    for _ in range(E):
        a, b = map(int, sys.stdin.readline().strip().split())
        v_list[a - 1].append(b - 1)
        v_list[b - 1].append(a - 1)
    
    # 이분 그래프 여부를 판별하고 결과 출력
    result = True
    for i in range(V):
        if visited[i] == 0:
            if not bfs(i):
                result = False
                break
    print("YES") if result else print("NO")

```

# 💡시간복잡도
O(N^2) - 정점개수(N)*간선(N-1)/2

# 💡 틀린 이유
문제를 잘못 접근함 연결요소 개수 문제 처럼 탐색하는 카운트를 계산하는 걸로 감

# 💡 다른 풀이

```python

```

# 💡 느낀점 or 기억할정보
visited에는 0과 1만 저장한다고 생각하고 문제를 풀었었다
하지만 이번 문제는 0과1 뿐만이 아니라 0,1,-1을 저장해야 풀 수 있는 문제였다

그래프와 집합에 대한 이야기가 나온다면 visited를 통해 집합을 표현하는 접근에 대해서도 고려해봐야 된다고 깨달았다