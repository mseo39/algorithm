# 이모티콘

## 💡**문제 분석 요약**

시간제한 2초
메모리 제한 512MB
 
영선이는 매우 기쁘기 때문에, 효빈이에게 스마일 이모티콘을 S개 보내려고 한다
영선이는 이미 화면에 이모티콘 1개를 입력했다. 이제, 다음과 같은 3가지 연산만 사용해서 이모티콘을 S개 만들어 보려고 한다.

1. 화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.
2. 클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.
3. 화면에 있는 이모티콘 중 하나를 삭제한다.

모든 연산은 1초가 걸린다. 또, 클립보드에 이모티콘을 복사하면 이전에 클립보드에 있던 내용은 덮어쓰기가 된다. 
클립보드가 비어있는 상태에는 붙여넣기를 할 수 없으며, 일부만 클립보드에 복사할 수는 없다. 
또한, 클립보드에 있는 이모티콘 중 일부를 삭제할 수 없다. 화면에 이모티콘을 붙여넣기 하면, 클립보드에 있는 이모티콘의 개수가 화면에 추가된다.

영선이가 S개의 이모티콘을 화면에 만드는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.

입력

첫째 줄에 S (2 ≤ S ≤ 1000) 가 주어진다.

출력

첫째 줄에 이모티콘을 S개 만들기 위해 필요한 시간의 최솟값을 출력한다.

## 💡**알고리즘 설계**

* 이전에 최소를 찾는데 경로가 겹치는 부분은 어떻게 해결하지 싶어서 큐에 정점을 넣을 때 거리도 넣은 적이 있는데 그걸 떠올려 풀었다
* 큐에는 [정점, 클립보드에 저장된 이모티콘 개수, 걸린 시간]을 저장한다
* 화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.
  * 화면에 보이는 것과 현재 복사된 개수가 같다면 복사할 의미가 없으니 이 경우는 패스한다
  * 복사한 후 내용을 수정해서 큐에 추가
* 클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.
  * 붙여넣기를 했을 때 범위 검사
  * 복사한 내용이 없다면 패스
* 화면에 있는 이모티콘 중 하나를 삭제한다.
  * 하나를 삭제했을 때 범위 검사
  * 방문 표시
  * 사제했을 때만 방문을 검사하는 이유는,,클립보드로 인해 정점이 중복되기 때문


## 💡코드

```python

import sys
from collections import deque

def bfs(v):
    # 초기화: 큐에 시작 노드와 현재 클립보드 상태, 이동 횟수를 저장
    queue = deque()
    queue.append([v, 0, 0])

    while queue:
        n = queue.popleft()
        # 도착 지점에 도달한 경우
        if n[0] == S:
            print(n[2])
            return
        # 붙여넣기
        if 0 < n[0] + n[1] < max_num and n[1] != 0:
            queue.append([n[0] + n[1], n[1], n[2] + 1])
        # 삭제
        if 0 < n[0] < max_num and visited[n[0] - 1] == 0:
            queue.append([n[0] - 1, n[1], n[2] + 1])
            visited[n[0] - 1] = 1
        # 복사
        if n[0] != n[1]:
            queue.append([n[0], n[0], n[2] + 1])

# 시작 지점 입력 받기
S = int(sys.stdin.readline())
max_num = 1001
visited = [0 for _ in range(max_num)]
bfs(1)

```

## 💡시간복잡도
O(V + E) 여기서 V는 정점의 수이고, E는 간선의 수

## 💡 틀린 이유
처음에 클립보드로 인해 정점이 중복되어 선택되어져 시간이 정확하게 저장되지 않는 문제로 인해 문제를 틀렸음
그래서 서로 다른 경로끼리 영향을 주지 않기 위해서 큐에 넣고 꺼내지면 1더하고 다시 넣고를 반복


## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
