# 2×n 타일링

## 💡**문제 분석 요약**

시간제한 0.15초
메모리 제한 128MB

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 💡**알고리즘 설계**

## 💡코드

```python

# sys 모듈을 사용하여 입력을 받습니다.
import sys

# 함수 정의: 1로 만들기 문제를 해결하는 함수
def solution():
    # 배열 arr을 초기화합니다. (0으로 초기화)
    arr = [0 for _ in range(n+2)]
    
    # 초기값 설정
    arr[2] = 1
    arr[3] = 1

    # 반복문을 통해 동적 계획법을 활용하여 최적해를 구합니다.
    for i in range(4, n+1):
        tmp = []
        
        # i를 3으로 나누어 떨어지는 경우, tmp에 해당 값을 추가합니다.
        if i % 3 == 0:
            tmp.append(arr[i // 3] + 1)
        
        # i를 2로 나누어 떨어지는 경우, tmp에 해당 값을 추가합니다.
        if i % 2 == 0:
            tmp.append(arr[i // 2] + 1)
        
        # i에서 1을 뺀 경우, tmp에 해당 값을 추가합니다.
        tmp.append(arr[i - 1] + 1)
        
        # tmp에 저장된 값 중 최솟값을 arr[i]에 저장합니다.
        arr[i] = min(tmp)

    # 결과를 출력합니다.
    print(arr[n])

# 정수 n을 입력 받습니다.
n = int(sys.stdin.readline())

# n이 1인 경우, 0을 출력합니다.
if n == 1:
    print(0)
else:
    # solution 함수를 호출하여 결과를 출력합니다.
    solution()

```

## 💡시간복잡도
O(N)

## 💡 틀린 이유                     

## 💡 다른 풀이


## 💡 느낀점 or 기억할정보
1~N까지 가는데 최소값을 구하려면 1부터 이동하면서 최소값을 찾아가면서 이동해야 한다
N에서 1로 가는 것은 더 많은 경우의 수를 검사하기 때문에 시간초과가 발생한다