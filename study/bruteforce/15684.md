# 사다리 조작

## 💡문제 분석 요약
```
시간제한 2초
메모리 제한 512MB

사다리 게임은 N개의 세로선과 M개의 가로선으로 이루어져 있다. 
인접한 세로선 사이에는 가로선을 놓을 수 있는데, 각각의 세로선마다 가로선을 놓을 수 있는 위치의 개수는 H이고, 모든 세로선이 같은 위치를 갖는다. 
아래 그림은 N = 5, H = 6 인 경우의 그림이고, 가로선은 없다.
초록선은 세로선을 나타내고, 초록선과 점선이 교차하는 점은 가로선을 놓을 수 있는 점이다. 
가로선은 인접한 두 세로선을 연결해야 한다. 단, 두 가로선이 연속하거나 서로 접하면 안 된다. 또, 가로선은 점선 위에 있어야 한다.

위의 그림에는 가로선이 총 5개 있다. 가로선은 위의 그림과 같이 인접한 두 세로선을 연결해야 하고, 가로선을 놓을 수 있는 위치를 연결해야 한다.
사다리 게임은 각각의 세로선마다 게임을 진행하고, 세로선의 가장 위에서부터 아래 방향으로 내려가야 한다. 
이때, 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동한 다음, 이동한 세로선에서 아래 방향으로 이동해야 한다.
위의 그림에서 1번은 3번으로, 2번은 2번으로, 3번은 5번으로, 4번은 1번으로, 5번은 4번으로 도착하게 된다. 
아래 두 그림은 1번과 2번이 어떻게 이동했는지 나타내는 그림이다.

1번 세로선	2번 세로선
사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다. 이때, i번 세로선의 결과가 i번이 나와야 한다. 그렇게 하기 위해서 추가해야 하는 가로선 개수의 최솟값을 구하는 프로그램을 작성하시오.

입력
첫째 줄에 세로선의 개수 N, 가로선의 개수 M, 세로선마다 가로선을 놓을 수 있는 위치의 개수 H가 주어진다. (2 ≤ N ≤ 10, 1 ≤ H ≤ 30, 0 ≤ M ≤ (N-1)×H)
둘째 줄부터 M개의 줄에는 가로선의 정보가 한 줄에 하나씩 주어진다.
가로선의 정보는 두 정수 a과 b로 나타낸다. (1 ≤ a ≤ H, 1 ≤ b ≤ N-1) b번 세로선과 b+1번 세로선을 a번 점선 위치에서 연결했다는 의미이다.
가장 위에 있는 점선의 번호는 1번이고, 아래로 내려갈 때마다 1이 증가한다. 세로선은 가장 왼쪽에 있는 것의 번호가 1번이고, 오른쪽으로 갈 때마다 1이 증가한다.
입력으로 주어지는 가로선이 서로 연속하는 경우는 없다.

출력
i번 세로선의 결과가 i번이 나오도록 사다리 게임을 조작하려면, 추가해야 하는 가로선 개수의 최솟값을 출력한다. 
만약, 정답이 3보다 큰 값이면 -1을 출력한다. 또, 불가능한 경우에도 -1을 출력한다.
```
## 💡문제 정리
* N개의 세로선 M개의 가로선
* 각각의 세로선마다 가로선을 놓을 수 있는 위치의 개수 H
* 가로선
  * 가로선은 인접한 세로선을 연결한다
  * 단 가로선을 서로 인접하면 안된다
  * 가로선에는 정해진 위치에만 놓을 수 있다
* 사다리 게임
  * 가장 위에서부터 아래로 이동하고 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동
* 이때! i번 세로선의 결과가 I번이 나와야 한다
  * 그렇게 하기 위해 최소 몇개의 가로선을 추가해야 하는가?
  * 최대 3개까지만 가능하며 4개 이상은 -1을 출력한다


## 💡알고리즘 설계
* 0,0에 사다리가 놓여져 있으면 0과 1이 연결되어 있다는 것이다 
  * 즉, 저장된 가로선은 오른쪽 세로선과 연결되어있다는 것으로
  * 맨 마지막 세로선에는 가로선을 놓지 않는다(어차피 오른쪽으로 이동 불가 이므로)
* dfs 탐색 방법은 완전탐색.md를 확인
* dfs가 실행될 때마다 i번 세로선이 i번이 나오는지 검사하고
  * 나온다면 최소값을 갱신해준다

## 💡코드

```python
import sys

# 체크 함수: 사다리가 올바르게 설치되었는지 확인
def chk():
    for y in range(N):
        x = 0
        tmp = y
        #맨 아래까지 이동
        while(x != H):
            #현재 위치에 사다리가 있다면 오른쪽으로 이동
            if bridge[x][tmp] == 1:
                tmp += 1
            #왼쪽 위치에 사다리가 있다면 왼쪽으로 이동
            elif tmp > 0 and bridge[x][tmp - 1] == 1:
                tmp -= 1
            x += 1 # 행 증가
        if tmp != y: #i번 세로선이 i가 아니라면
            return False
    return True

# 사다리를 놓을 수 있는지 확인하는 함수
def bridge_chk(x, y):
    # 사다리가 인접하면 안되기 때문에 현재 위치, 왼쪽, 오른쪽에 사다리가 있는지 확인하는 것
    if bridge[x][y] == 0 and (y == 0 or (y > 0 and bridge[x][y - 1] == 0)) and bridge[x][y + 1] == 0:
        return True
    return False

# DFS로 사다리 설치하기
def dfs(cnt, X, Y):
    global ans
    # 3보다 크거나 현재 최소값보다 크거나 같다면 종료
    if cnt > 3 or cnt >= ans:
        return
    if chk(): # i번에서 i번으로 가는 조건을 충족한다면
        ans = min(ans, cnt)
    now = Y
    for x in range(X, H):
        for y in range(now, N - 1): #마지막 세로선에는 가로선을 놓지 않는다(어차피 오른쪽으로 이동 불가 이므로)
            if bridge_chk(x, y):
                bridge[x][y] = 1
                dfs(cnt + 1, x, y + 2)
                bridge[x][y] = 0
        now = 0

# 입력 받기
N, M, H = map(int, sys.stdin.readline().strip().split())
bridge = [[0 for _ in range(N)] for _ in range(H)]

# 입력값으로부터 기존에 설치된 사다리 정보 업데이트
for _ in range(M):
    a, b = map(int, sys.stdin.readline().strip().split())
    bridge[a - 1][b - 1] = 1

# 최소 설치 횟수 초기화 및 DFS 시작
ans = 4
dfs(0, 0, 0)

# 정답 출력
print(ans if ans != 4 else -1)

```

## 💡시간복잡도

## 💡 틀린 이유

## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
이전에 1차원 배열에서 중복없이 조합을 구할 때에 대해 얘기한 적이 있다 이번에는 2차원배열에 대한 것이었는데
완전탐색.md에 정리해놓았다