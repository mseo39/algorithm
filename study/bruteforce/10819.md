# 💡**문제 분석 요약**

시간제한: 1초
메모리 제한 256MB

N개의 정수로 이루어진 배열 A가 주어진다. 이때, 배열에 들어있는 정수의 순서를 적절히 바꿔서 다음 식의 최댓값을 구하는 프로그램을 작성하시오
|A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|

입력
첫째 줄에 N (3 ≤ N ≤ 8)이 주어진다. 둘째 줄에는 배열 A에 들어있는 정수가 주어진다. 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다.

출력
첫째 줄에 배열에 들어있는 수의 순서를 적절히 바꿔서 얻을 수 있는 식의 최댓값을 출력한다

# 💡**알고리즘 설계**
입력된 숫자들을 이용하여 만들어질 수 있는 배열을 만들어 주는 함수를 만들어줘야한다

N길이의 배열이 완성되면 문제에 주어진 |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|를 계산한다
계산한 값을 현재 최대값보다 크다면 최대값을 갱신한다

# 💡코드

```python
import sys

# 최대값 계산 함수 정의
def calcurlator():
    global max_num
    # 현재 배열에서 인접한 원소 간의 차이의 절댓값을 모두 더한 값 중 최댓값 갱신
    max_num = max(max_num, sum([abs(arr[i] - arr[i+1]) for i in range(N-1)]))

# 순열을 구하는 재귀 함수 정의
def solution():
    # 배열의 길이가 N과 같아지면 최대값을 계산하고 반환
    if len(arr) == N:
        calcurlator()
        return
    # N_list에 있는 원소들 중에서 아직 사용되지 않은 것을 배열에 추가하고 재귀 호출
    for i in N_list:
        if arr.count(i) < N_list.count(i):
            arr.append(i)
            solution()
            arr.pop()

# 입력 받기
N = int(sys.stdin.readline())
N_list = list(map(int, sys.stdin.readline().strip().split()))
max_num = -1401  # 최대값 초기화
arr = []  # 순열을 저장할 배열

# 순열 구하기
solution()

# 최대값 출력
print(max_num)

```

# 💡시간복잡도

모든 경우의 수를 확인하여 O(N!)이지만 N의 최대가 8로 작은 값이기 때문에 모든 경우의 수를 확인했다

# 💡 틀린 이유

문제 정보를 잘못해석함
1. |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|를 |A[0] - A[1]| + |A[2] - A[3]| + 이렇게 해석하고 품
2. 문제에서는 주어지는 배열이 중복이 되지 않는다는 말이 없는데 중복이 불가능하게 만듦 
그래서 
6
2 -4 -4 0 1 4
위 입력에서 잘못된 값이 출력되었음 그래서 현재 만들고 있는 배열의 i의 개수와 입력받은 배열의 i개수를 비교하는 코드를 넣어줌

# 💡 틀린 부분 수정 or 다른 풀이



# 💡 느낀점 or 기억할정보

