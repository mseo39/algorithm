# 연산자 끼워넣기

## 💡**문제 분석 요약**

```
시간제한 2초
메모리 제한 512MB

N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 
연산자는 덧셈(+), 뺄셈(-), 곱셈(x), 나눗셈(÷)으로만 이루어져 있다.
우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.
예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(x) 1개, 나눗셈(÷) 1개인 경우에는 
총 60가지의 식을 만들 수 있다. 

예를 들어, 아래와 같은 식을 만들 수 있다.
1+2+3-4x5÷6
1÷2+3+4-5x6
1+2÷3x4-5+6
1÷2x3-4+5+6
식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 
음수를 양수로 나눌 때는 C++14의 기준을 따른다. 
즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.

1+2+3-4x5÷6 = 1
1÷2+3+4-5x6 = 12
1+2÷3x4-5+6 = 5
1÷2x3-4+5+6 = 7
N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.

입력
첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 
둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 100) 
셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(x)의 개수, 나눗셈(÷)의 개수이다.

출력
첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 
둘째 줄에는 최솟값을 출력한다. 
연산자를 어떻게 끼워넣어도 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 
또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.
```

## 💡**알고리즘 설계**

* dfs(첫 요소, 깊이): 깊이 1부터 시작 다음 요소와 계산하기 위해 1부터 함
* 계산 결과가 최소 -10억 최대 10억 이었으므로 이로 초기화
* 왼쪽에서 오른쪽으로 이동하면서 계산하면 넘어간다
  * dfs(지금까지 계산한것, 현재 같이 연산할 요소)
  * 123456
  * 1+2=3 456
  * 3-4=-1 56
  * -1+5=4 6
  * 4+6=10
* 종료시점
  * 모든 연산자를 사용했을 때
  * 더 이상 갱신할 수 없을 때
* +,-,*,/ 을 하나씩 선택
  * 해당 연산자가 지정한 개수보다 적게 선택되었으면 
    * 해당 연산자 개수 +1 해주기
    * 계산
    * dfs 호출
    * 해당 연산자 개수 -1해주기 


## 💡코드

```python

import sys

# 깊이 우선 탐색 함수 정의
def dfs(value, depth):
    global min_num
    global max_num

    # 종료 조건: 모든 연산자를 사용한 경우
    if visited == O_num:
        min_num = min(min_num, value)
        max_num = max(max_num, value)
        return

    # 현재까지의 결과가 주어진 범위 내에 있고, 다음 연산자를 사용할 수 있는 경우에만 진행
    if (min_num <= value and ((value >= 0 and visited[1] == 0 and visited[3] == 0) or
                              (value < 0 and visited[1] == 0 and visited[2] == 0))) and \
            (max_num >= value and ((value >= 0 and visited[0] == 0 and visited[2] == 0) or
                                   (value < 0 and visited[0] == 0 and visited[3] == 0))):
        print(value, depth, visited)
        return

    # 모든 연산자에 대해 재귀 호출
    for i in range(4):
        if visited[i] < O_num[i]:
            visited[i] += 1
            tmp = value

            # 각 연산자에 따라 임시 결과 값 계산
            if i == 0:
                tmp += A[depth]
            elif i == 1:
                tmp -= A[depth]
            elif i == 2:
                tmp *= A[depth]
            else:  # 정수 나눗셈인 경우
                if tmp < 0:
                    tmp = (-tmp) // A[depth]
                    tmp = -tmp
                else:
                    tmp = tmp // A[depth]

            # 재귀 호출
            dfs(tmp, depth + 1)

            # 백트래킹: 방문 상태 복구
            visited[i] -= 1

# 입력 받기
N = int(sys.stdin.readline())
A = list(map(int, sys.stdin.readline().strip().split()))
O_num = list(map(int, sys.stdin.readline().strip().split()))
O = ["+", "-", "*", "//"]
visited = [0, 0, 0, 0]
min_num = 10**9 + 1
max_num = -10**9 - 1

# 초기 호출
dfs(A[0], 1)

# 최댓값과 최솟값 출력
print(max_num)
print(min_num)


```

## 💡시간복잡도
O(4^N)입니다. 여기서 N은 주어진 숫자의 개수입니다. 이는 각각의 연산자(+, -, *, //)에 대해 4가지 경우가 있기 때문

## 💡 틀린 이유
나누기할 때 

## 💡 다른 풀이

```python

```

## 💡 느낀점 or 기억할정보
또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다.

이 부분에서도 파이썬은 int(a/b)해주면 된다