#후위표기식2
"""
@첫째 줄에 피연산자의 개수가 주어진다.

@그리고 둘째 줄에는 후위표기식이 주어진다.
(여기서 피연산자는 A~Z의 영대문자이며 A부터 순서대로 N개의 영대문자만이 사용되며,
길이는 100을 넘지 않는다)
그리고 셋째 줄부터 N+2번째 줄까지 각 피연산자에 대응하는 값이 주어진다

3번째 줄에는 A에 해당하는 값
4번째 줄에는 B에 해당하는 값,
5번째 줄에는 C에 해당하는 값----이 주어진다

그리고 피연산자에 대응하는 값은 100보다 작거나 같은 자연수이다.

후위표기식을 앞에서부터 계산했을 때, 식의 결과와 중간 결과가 -20억보다
크거나 같고, 20억 보다 작거나 같은 입력만 주어진다

=========
피연산자를 만나면 스택에 집어넣는다
연산자를 만나면 스택에서 2개를 꺼내주고 계산후에 다시 스택에 넣어준다
"""
import sys

I=sys.stdin.readline

#첫째 줄에는 피연산자의 개수가 주어진다
N=int(I())
#후위표기식을 입력받는다
S=I().strip()

#숫자들을 입력받음
num_list=list(int(I()) for _ in range(N))

#빈 스택을 생성
stack=[]

for i in S:
    #연산자라면
    if(i=="*" or i=="+" or i=="/" or i=="-" or i=="%"):
        #스택에서 피연산자를 꺼내고
        num1=stack.pop()
        num2=stack.pop()
        #연산하여 stack에 넣어준다
        #참고로 eval함수는 문자열로된 식ㅇ을 계산해준다
        stack.append(eval("{}{}{}".format(num2,i,num1)))
    #피연산자라면
    else:
        #스택에 알파벳에 해당하는 숫자를 찾아서 넣는다
        """
        나는 알파벳의 십진법을 이용하여 계산하였다
        - 숫자를 입력받을 때, A부터 차례대로 해당되는 것을 이용
        - 알파벳의 십진수는 65부터 시작하므로
          알파벳의 십진수 -65한 값을 인덱스로 사용하여
          해당되는 숫자를 찾아 스택에 push해주었다

        """
        stack.append(num_list[ord(i)-65])

"""
처음에 틀렸었는데 이유는 round 함수를 사용하여 출력했기 때문이다
찾아보니 round함수의 단점은 0을 원하는 만큼 출력하지 않는다는 것이었다
하지만
format 서식지정을 사용한다면
사용법은 이렇다
{:.2f}는 소수점 2자리까지 출력하겠다는 뜻이다

내가 원하는 만큼 전부 출력할 수 있다(0도 전부)

- format 함수 사용법에 대해서 더 자세히 공부해보자
"""
print("{:.2f}".format(stack[0]))